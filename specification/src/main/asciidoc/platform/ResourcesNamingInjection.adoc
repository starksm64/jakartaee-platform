== [[a567]]Resources, Naming, and Injection

This chapter describes how applications
declare dependencies on external resources and configuration parameters,
and how those items are represented in the Jakarta EE naming system and can
be injected into application components. These requirements are based on
annotations defined in the Java Metadata specification and features
defined in the Java Naming and Directory Interface™ (JNDI)
specification. The _Resource_ annotation described here is defined in
more detail in the Common Annotations specification. The _EJB_
annotation described here is defined in more detail in the Enterprise
JavaBeans specification. The _PersistenceUnit_ and _PersistenceContext_
annotations described here are defined in more detail in the Java
Persistence specification. The _Inject_ annotation described here is
defined in the Dependency Injection for Java specification, and its
usage in Jakarta EE applications is defined in the Contexts and Dependency
Injection for the Jakarta EE Platform specification.

=== Overview

The requirements defined in this chapter
address the following two issues:

* The Application Assembler and Deployer should
be able to customize the behavior of an application’s business logic
without accessing the application’s source code. Typically this will
involve specification of parameter values, connection to external
resources, and so on. Deployment descriptors provide this capability
* Applications must be able to access resources
and external information in their operational environment without
knowledge of how the external information is named and organized in that
environment. The JNDI naming context and Java language annotations
provide this capability.

=== Chapter Organization

The following sections contain the Jakarta EE
platform solutions to the above issues:

* link:#a607[See
JNDI Naming Context],” defines general rules for the use of the JNDI
naming context and its interaction with Java language annotations that
reference entries in the naming context.
* link:#a732[See
Responsibilities by Jakarta EE Role],” defines the general responsibilities
for each of the Jakarta EE roles such as Application Component Provider,
Application Assembler, Deployer, and Jakarta EE Product Provider.
* link:#a751[See
Simple Environment Entries],” defines the basic interfaces that specify
and access the application component’s naming environment. The section
illustrates the use of the application component’s naming environment
for generic customization of the application component’s business logic.
* link:#a936[See
Enterprise JavaBeans™ (EJB) References],” defines the interfaces for
obtaining the business interface, no-interface view, or home interface
of an enterprise bean using an EJB reference. An EJB reference is a
special entry in the application component’s environment.
* link:#a1118[See
Web Service References],” refers to the specification for web service
references.
* link:#a1120[See
Resource Manager Connection Factory References],” defines the interfaces
for obtaining a resource manager connection factory using a resource
manager connection factory reference. A resource manager connection
factory reference is a special entry in the application component’s
environment.
* link:#a1242[See
Resource Environment References],” defines the interfaces for obtaining
an administered object that is associated with a resource using a
resource environment reference. A resource environment reference is a
special entry in the application component’s environment.
* link:#a1266[See
Message Destination References],” defines the interfaces for declaring
and using message destination references.
* link:#a1334[See
UserTransaction References],” describes the use by eligible application
components of references to a _UserTransaction_ object in the
component’s environment to start, commit, and abort transactions.
* link:#a1376[See
TransactionSynchronizationRegistry References],” describes the use by
eligible application components of references to a
_TransactionSynchronizationRegistry_ object in the component’s
environment.
* link:#a1385[See
ORB References],” describes the use by eligible application components
of references to a CORBA _ORB_ object in the component’s environment.
* link:#a1416[See
Persistence Unit References],” describes the use by eligible application
components of references to an _EntityManagerFactory_ object in the
component’s environment.
* link:#a1513[See
Persistence Context References],” describes the use by eligible
application components of references to an _EntityManager_ object in the
component’s environment.
* link:#a1607[See
Application Name and Module Name References],” describes the use by
eligible application components of references to the names of the
current application and module.
* link:#a1613[See
Application Client Container Property],” describes the use by eligible
application components of references to the application client container
property.
* link:#a1619[See
Validator and Validator Factory References],” describes the use by
eligible application components of references to the _Validator_ and
_ValidatorFactory_ objects in the component’s environment.
* link:#a1652[See
Resource Definition and Configuration],” describes the use by eligible
application components of metadata that may be used to define resources
in the component’s environment.
* link:#a1688[See
DataSource Resource Definition],” describes the use by eligible
application components of references to _DataSource_ resources in the
component’s environment.
* link:#a1756[See
JMS Connection Factory Resource Definition],” describes the use by
eligible application components of references to JMS _ConnectionFactory_
resources in the component’s environment.
* link:#a1817[See
JMS Destination Definition],” describes the use by eligible application
components of references to JMS _Destination_ resources in the
component’s environment.
* link:#a1863[See
Mail Session Definition],” describes the use by eligible application
components of references to Mail _Session_ resources in the component’s
environment.
* link:#a1917[See
Connector Connection Factory Definition],” describes the use by eligible
application components of references to Connector connection factory
resources in the component’s environment.
* link:#a1967[See
Connector Administered Object Definition],” describes the use by
eligible application components of references to Connector administered
object resources in the component’s environment.
* link:#a2009[See
Default Data Source],” describes the use by eligible application
components of references to the default DataSource in the component’s
environment.
* link:#a2025[See
Default JMS Connection Factory],” describes the use by eligible
application components of references to the default JMS
ConnectionFactory in the component’s environment.
* link:#a2042[See
Default Concurrency Utilities Objects],” describes the use by eligible
application components of references to the default Concurrency
Utilities objects in the component’s environment.
* link:#a2067[See
Managed Bean References],” describes the use by eligible application
components of references to Managed Beans.
* link:#a2099[See
Bean Manager References],” describes the use by eligible application
components of references to a _BeanManager_ object in the component’s
environment.
* link:#a2112[See
Support for Dependency Injection],” describes support for the use of the
Dependency Injection APIs.

=== Required Access to the JNDI Naming Environment

Jakarta EE application clients, enterprise beans,
and web components are required to have access to a JNDI naming
environmentlink:#a3651[4]. The containers for these application
component types are required to provide the naming environment support
described here.

Annotations and deployment descriptors are the
main vehicles for conveying access information to the Application
Assembler and Deployer about application components’ requirements for
customization of business logic and access to external information. The
annotations described here are available for use by all application
component types. The deployment descriptor entries described here are
present in identical form in the deployment descriptor schemas for each
of these application component types. See the corresponding
specification of each application component type for the details.

=== [[a607]]JNDI Naming Context

The application component’s naming environment
is a mechanism that allows customization of the application component’s
business logic during deployment or assembly. Use of the application
component’s environment allows the application component to be
customized without the need to access or change the application
component’s source code.

=== The Application Component’s Environment

The container implements the application
component’s environment, and provides it to the application component
instance as a JNDI naming context. The application component’s
environment is used as follows:

. The application component’s business methods
make use of entries from the environment. The business methods may
access the environment using the JNDI interfaces or lookup methods on
component-specific context objects. Also, entries from the environment
may be injected into the application component’s fields or methods. The
Application Component Provider declares in the deployment descriptor, or
via annotations, all the environment entries that the application
component expects to be provided in its environment at runtime. For each
environment entry, the Application Component Provider can also specify
in the deployment descriptor, or via annotations, the JNDI name of
another environment entry whose value should be used to initialize the
environment entry being defined (“lookup” functionality).
. The container provides an implementation of
the JNDI naming context that stores the application component
environment. The container also provides the tools that allow the
Deployer to create and manage the environment of each application
component.
. The Deployer uses the tools provided by the
container to initialize the environment entries that are declared in the
application component’s deployment descriptor or via annotations. The
Deployer can set and modify the values of the environment entries. As
part of this process, the Deployer is allowed to override any “lookup”
information associated with the application component.
. The container injects entries from the
environment into application component fields or methods as specified by
the application component’s deployment descriptor or by annotations on
the application component class.
. The container also makes the environment
naming context available to the application component instances at
runtime. The application component’s instances may use the JNDI
interfaces or component context lookup methods to obtain the values of
the environment entries. __

=== [[a616]]Application Component Environment Namespaces

The application component’s naming environment
is composed of four logical namespaces, representing naming environments
with different scopes. The four namespaces are: __

*  _java:comp_ – Names in this namespace are
per-component (for example, per enterprise bean). Except for components
in a web module, each component gets its own _java:comp_ namespace, not
shared with any other component. Components in a web module do not have
their own private component namespace. __ See note below.
*  _java:module_ – Names in this namespace are
shared by all components in a module (for example, all enterprise beans
in a single EJB module, or all components in a web module). __
*  _java:app_ – Names in this namespace are
shared by all components in all modules in a single application, where
“single application” means a single deployment unit, such as a single
ear file, a single module deployed standalone, etc. For example, a war
file and an EJB jar file in the same ear file would both have access to
resources in the _java:app_ namespace. __
*  _java:global_ – Names in this namespace are
shared by all applications deployed in an application server instance.
Note that an application server instance may represent a single server,
a cluster of servers, an administrative domain containing many servers,
or even more. The scope of an application server instance is
product-dependent, but it must be possible to deploy multiple
applications to a single application server instance.

Note that in environments in which an
application is deployed multiple times—such as, for example, in cloud
environments, where multiple instances of the same application might be
deployed on behalf of multiple tenants—the namespace for each
application instance would be disjoint from the namespace of any other
instance of that same application.

For historical reasons, the _java:comp_
namespace is shared by all components in a web module. To preserve
compatibility, this specification doesn’t change that. In a web module,
_java:comp_ refers to the same namespace as _java:module_ . It is
recommended that resources in a web module that are intended to be
shared by more than one component be declared in the _java:module/env_
namespace.

Note that an application client is a module
with only a single component.

Note also that resource adapter (connector)
modules may not define resources in any of the component namespaces, but
may look up resources defined by other components. All the _java:_
namespaces accessible in a resource adapter are the namespaces of the
component that called the resource adapter (when called in the context
of a component).

If multiple application components declare an
environment entry in one of the shared namespaces, all attributes of
that entry must be identical in each declaration. For example, if
multiple components declare a resource reference with the same
_java:app_ name, the _authentication_ and _shareable_ attributes must be
identical.

If all attributes of each declaration of a
shared environment entry are not identical, this must be reported as a
deployment error to the Deployer. The deployment tool may allow the
Deployer to correct the error and continue deployment.

The default JNDI namespace for resource
references and resource definitions must always be _java:comp/env_ .
Note that this applies to both the case where no name has been supplied
so the rules for choosing a default name are used, and the case where a
name has been supplied explicitly but the name does not specify a
_java:_ namespace. Since the _java:comp_ namespace is not available in
some contexts, use of that namespace in such a context should result in
a deployment error. Likewise, the _java:module_ namespace is not valid
in some contexts; use of that namespace in such contexts should result
in a deployment error. Environment entries may be declared in any one of
the defined namespaces by explicitly including the namespace prefix
before the name.

It is recommended but not required that
environment entries be created in the _env_ subcontext of the
corresponding naming context. For example, entries shared within a
module should be declared in the _java:module/env_ context. Note that
names that are not under the _env_ subcontext may conflict with the
current or future versions of this specification, with server-defined
names, such as the names of applications or modules, or with
server-defined resources. Names in the _env_ subcontexts of any of the
namespaces must only be created by an explicit declaration in an
application or by an explicit action by an administrator; the
application server must not predefine any names in the _env_ subcontext
of any of the namespaces, or in any subcontext of any such _env_
context.

An environment entry declared in the
_application.xml_ descriptor must specify a JNDI name in the _java:app_
or _java:global_ namespace, for example: _java:app/env/myString_ or
_java:global/someValue_ . The specification of a _java:comp_ or
_java:module_ name for an environment entry declared in the
_application.xml_ descriptor must be reported as a deployment error to
the Deployer.

A Jakarta EE product may impose security
restrictions on access of resources in the shared namespaces. However,
it must be possible to deploy applications that define resources in the
shared namespaces that are usable by different entities at the given
scope. For example, it must be possible to deploy an application that
defines a resource, using various forms of metadata declaration, in the
_java:global_ namespace that is usable by a separate application.

=== Accessibility of Environment Entry Types

All objects defined in environment entries of
any kind (either in deployment descriptors or through annotations) must
be specified to be of a Java type that is accessible to the component.
Accessibility of Java classes is specified in section
link:#a3040[See Class Loading
Requirements].” If the object is of type _java.lang.Class_ , the _Class_
object must refer to a class that is accessible to the component. Note
that in cases where the container may return an implementation subtype
of the requested type, the implementation subtype might not be
accessible to the component.

=== Sharing of Environment Entries

Each application component defines its own set
of dependencies that must appear as entries in the application
component’s environment. All instances of an application component
within the same application instance within the same container share the
same environment entries. Application component instances are not
allowed to modify the environment at runtime.

In general, lookups of objects in the JNDI
_java:_ namespace are required to return a new instance of the requested
object every time. Exceptions are allowed for the following:

* The container knows the object is immutable
(for example, objects of type _java.lang.String_ ), or knows that the
application can’t change the state of the object.
* The object is defined to be a singleton, such
that only one instance of the object may exist in the JVM.
* The name used for the lookup is defined to
return an instance of the object that might be shared. The names
_java:comp/ORB_ , _java:comp/ValidatorFactory_ , and
_java:comp/BeanManager_ are such names.

In these cases, a shared instance of the object
may be returned. In all other cases, a new instance of the requested
object must be returned on each lookup. Note that, in the case of
resource adapter connection objects, it is the resource adapter’s
_ManagedConnectionFactory_ implementation that is responsible for
satisfying this requirement.

Each injection of an object corresponds to a
JNDI lookup. Whether a new instance of the requested object is injected,
or whether a shared instance is injected, is determined by the rules
described above. __

=== Annotations and Injection

As described in the following sections, a field
or method of certain container-managed component classes may be
annotated to request that an entry from the application component’s
environment be injected into the class. The specifications for the
different containers indicate which classes are considered
container-managed classes; not all classes of a given type are
necessarily managed by the container.

Any of the types of resources described in
this chapter may be injected. Injection may also be requested using
entries in the deployment descriptor corresponding to each of these
resource types. The field or method may have any access qualifier (
_public_ , _private_ , etc.). For all classes except application client
main classes, the fields or methods must not be _static_ . Because
application clients use the same lifecycle as Java SE applications, no
instance of the application client main class is created by the
application client container. Instead, the _static_ _main_ method is
invoked. To support injection for the application client main class, the
fields or methods annotated for injection must be _static_ .

A field of a class may be the target of
injection. The field must not be _final_ . By default, the name of the
field is combined with the fully qualified name of the class and used
directly as the name in the application component’s naming context. For
example, a field named _myDatabase_ in the class _MyApp_ in the package
_com.example_ would correspond to the JNDI name
_java:comp/env/com.example.MyApp/myDatabase_ . The annotation also
allows the JNDI name to be specified explicitly. When a deployment
descriptor entry is used to specify injection, the JNDI name and the
field name are both specified explicitly. Note that, by default, the
JNDI name is relative to the _java:comp/env_ naming context.

Environment entries may also be injected into a
class through methods that follow the naming conventions for JavaBeans
properties. The annotation is applied to the _set_ method for the
property, which is the method that is called to inject the environment
entry into the class. The JavaBeans property name (not the method name)
is used as the default JNDI name. For example, a method named
_setMyDatabase_ in the same _MyApp_ class would correspond to the same
JNDI name _java:comp/env/com.example.MyApp/myDatabase_ as the field
_myDatabase_ .

Each resource may only be injected into a
single field or method of a given name in a given class. Requesting
injection of the _java:comp/env/com.example.MyApp/myDatabase_ resource
into both the _setMyDatabase_ method and the _myDatabase_ field is an
error. Note, however, that either the field or the method could request
injection of a resource of a different (non-default) name. By explicitly
specifying the JNDI name of a resource, a single resource may be
injected into multiple fields or methods of multiple classes.

The specifications for the various application
component types describe which classes may be annotated for injection,
as summarized in link:#a651[See
Component classes supporting injection].

The component classes listed in
link:#a651[See Component classes
supporting injection] with support level “Standard” all support Jakarta EE
resource injection, as well as PostConstruct and PreDestroy callbacks.
In addition, if CDI is enabled—which it is by default—these classes also
support CDI injection, as described in
link:#a2112[See Support for Dependency
Injection]”, and the use of interceptorslink:#a3652[5]. The
component classes listed with support level “Limited” only support Jakarta
EE field injection and the PostConstruct callback. Note that these are
application client main classes, where field injection is into static
fields.

{empty}The specifications for the various
application component types also describe when injection occurs in the
lifecycle of the component. Typically injection will occur after an
instance of the class is constructed, but before any business methods
are called. If the container fails to find a resource needed for
injection, initialization of the class must fail, and the class must not
be put into service.link:#a653[See
Classes supporting injection]

=== [[a651]]Component classes supporting injection

Spec

[[a653]]Classes supporting
injection

Support level

Servlet

servlets

servlet filters

event listeners

HTTP upgrade handlers

Standard

Standard

Standard

Standard

JSP

tag handlers

tag library event listeners

Standard

Standard

JSF

{empty}managed classeslink:#a3653[6]

Standard

JAX-WS

service endpoints

handlers

Standard

Standard

JAX-RS

{empty}JAX-RS
componentslink:#a3654[7]

Standard

WebSocket

endpoints

Standard

EJB

beans

Standard

Interceptor

{empty}interceptorslink:#a3655[8]

Standard

Java Persistence

entity listeners

Standard

Managed Beans

managed beans

Standard

{empty}CDIlink:#a3656[9]



{empty}CDI-style managed
beanslink:#a3657[10]

{empty}decoratorslink:#a3658[11]

Standard

Standard

Jakarta EE platform

main class (static)

login callback handler

Limited

Standard

Annotations may also be applied to the class
itself. These annotations declare an entry in the application
component’s environment but do not cause the resource to be injected.
Instead, the application component is expected to use JNDI or a
component context lookup method to lookup the entry. When the annotation
is applied to the class, the JNDI name and the environment entry type
must be specified explicitly. __

Resource annotations may appear on any of the
classes listed above, or on any superclass of any class listed above. A
resource annotation on any class in the inheritance hierarchy defines a
resource needed by the application component. However, injection of
resources follows the Java language overriding rules for visibility of
fields and methods. A method definition that overrides a method on a
superclass defines the resource, if any, to be injected into that
method. An overriding method may request injection even though the
superclass method does not request injection, it may request injection
of a different resource than is requested by the superclass, or it may
request no injection even though the superclass method requests
injection.

In addition, fields or methods that are not
visible in or are hidden (as opposed to overridden) by a subclass may
still request injection. This allows, for example, a private field to be
the target of injection and that field to be used in the implementation
of the superclass, even though the subclass has no visibility into that
field and doesn’t know that the implementation of the superclass is
using an injected resource. Note a declaration of a field in a subclass
with the same name as a field in a superclass always causes the field in
the superclass to be hidden.

In some cases a class may need to perform
initialization of its own after all resources have been injected. To
support this case, one method of the class may be annotated with the
_PostConstruct_ annotation (or, equivalently, specified using the
_post-construct_ entry of a deployment descriptor). This method will be
called after all injections have occured and before the class is put
into service. This method will be called even if the class doesn’t
request any resources to be injected. Similarly, for classes whose
lifecycle is managed by the container, the _PreDestroy_ annotation (or,
equivalently, the _pre-destroy_ entry of a deployment descriptor) may be
applied to one method that will be called when the class is taken out of
service and will no longer be used by the container. Each class in a
class hierarchy may have _PostConstruct_ and _PreDestroy_ methods. The
order in which the methods are called matches the order of the class
hierarchy with methods on a superclass being called before methods on a
subclass.

The _PostConstruct_ and _PreDestroy_
annotations are specified by the Common Annotations specification. All
classes that support injection also support the _PostConstruct_
annotation. All classes for which the container manages the full
lifecycle of the object also support the _PreDestroy_ annotation.

Starting with Java EE 7, CDI support is
enabled by default. CDI bean-defining annotations and the _beans.xml_
descriptor are used to determine which classes are CDI beans and
eligible for injection into other objects. Similarly, the annotation
metadata and the _beans.xml_ descriptor are used by CDI to determine
which interceptors are eligible to be applied. See the CDI specification
and the Interceptors specification for the rules that determine which
classes are CDI beans and the treatment of interceptors.

=== Annotations and Deployment Descriptors

Environment entries may be declared by use of
annotations, without need for any deployment descriptor entries.
Environment entries may also be declared by deployment descriptor
entries. The same environment entry may be declared using both an
annotation and a deployment descriptor entry. In this case, the
information in the deployment descriptor entry may be used to override
some of the information provided in the annotation. This approach may be
used by an Application Assembler or Deployer to override information
provided by the Application Component Developer. Applications should not
use deployment descriptor entries to request injection of a resource
into a field or method that has not been designed for injection.

The following list describes the rules for how
a deployment descriptor entry may override a _Resource_ annotation.

* The relevant deployment descriptor entry is
located based on the JNDI name used with the annotation (either
defaulted or provided explicitly).
* The type specified in the deployment
descriptor must be assignable to the type of the field or property.
* The description, if specified, overrides the
description element of the annotation.
* The injection target, if specified, defines
additional injection points for the resource.
* The _mapped-name_ element, if specified,
overrides the _mappedName_ element of the annotation.
* The _res-sharing-scope_ element, if
specified, overrides the _shareable_ element of the annotation. In
general, the Application Assembler or Deployer should not change this
value as doing so is likely to break the application.
* The _res-auth_ element, if specified,
overrides the _authenticationType_ element of the annotation. In
general, the Application Assembler or Deployer should not change this
value as doing so is likely to break the application.
* The _lookup-name_ element, if specified,
overrides the _lookup_ element of the annotation.

It is an error to request injection of two
resources into the same target. The behavior of an application that does
so is undefined.

The rules for how a deployment descriptor
entry may override an _EJB_ annotation are included in the EJB
specification. The rules for how a deployment descriptor entry may
override a _WebServiceRef_ annotation are included in the Web Services
for Jakarta EE specification.

A PostConstruct method may be specified using
either the _PostConstruct_ annotation on the method or the
_post-construct_ deployment descriptor entry. Similarly, a PreDestroy
method may be specified using either the _PreDestroy_ annotation on the
method or the _pre-destroy_ deployment descriptor entry.

=== Other Naming Context Entries

In addition to environment entries declared by
application components, other items will appear in the naming context,
as specified by this and other specifications. Following are some of
these entries. This is not an exhaustive list; consult the corresponding
specification for details.

* All enterprise beans in an application are
given entries in the shared namespaces. See the EJB specification for
details.
* All web applications are given names in the
shared namespaces. The names correspond to the complete URL of the web
application. See the Servlet specification for details.
* Objects representing several container
services are defined in the _java:comp_ namespace. See, for example,
link:#a1334[See UserTransaction
References],” link:#a1376[See
TransactionSynchronizationRegistry References],” and
link:#a1385[See ORB References].”
* Strings providing the current module name
and application name are defined in the _java:comp_ namespace. See
link:#a1607[See Application Name and
Module Name References].”

=== [[a732]]Responsibilities by Jakarta EE Role

This section describes the responsibilities for
each Jakarta EE role that apply to all uses of the Jakarta EE naming context.
The sections that follow describe the responsibilities that are specific
to the different types of objects that may be stored in the naming
context.

=== Application Component Provider’s Responsibilities

The Application Component Provider may make use
of three techniques for accessing and managing the naming context.
First, the Application Component Provider may use Java language
annotations to request injection of a resource from the naming context,
or to declare elements that are needed in the naming context. Second,
the component may use the JNDI APIs to access entries in the naming
context. Third, deployment descriptor entries may be used to declare
entries needed in the naming context, and to request injection of these
entries into application components. Deployment descriptor entries may
also be used to override information provided by annotations.

As part of the declaration of elements in the
naming context, the Application Component Provider can specify the JNDI
name of a resource to be looked up in the naming context to initialize
the element being declared. The JNDI name in question may belong to any
of the namespaces that compose the application component environment.

To ensure that it has access to the correct
_javax.naming.InitialContext_ implementation provided by the container,
a portable application component must not specify the
_java.naming.factory.initial_ property, must not specify a
_URLContextFactory_ for the _“java”_ scheme-id, and must not call the
_javax.naming.spi.NamingManager.setInitialContextFactoryBuilder_ method.

=== Application Assembler’s Responsibilities

The Application Assembler is allowed to modify
the entries in the naming context set by the Application Component
Provider, and is allowed to set the values of those entries for which
the Application Component Provider has not specified any values. The
Application Assembler may use the deployment descriptor to override
settings made by the Application Component Provider in the source code
using annotations.

=== Deployer’s Responsibilities

The Deployer must ensure that all the entries
declared by an application component are created and properly
initialized.

The Deployer can modify the entries that have
been previously set by the Application Component Provider and/or
Application Assembler, and must set the values of those entries for
which a required value has not been specified. If an annotation contains
the _lookup_ element or a deployment descriptor entry includes the
_lookup-name_ element, the Deployer should bind it to the entry
specified as the target of the lookup. Deployment should fail if the
_lookup_ element of an annotation or the _lookup-name_ element in a
deployment descriptor entry does not specify a name with an explicit
_java:_ namespace. The Deployer may also use product-specific resource
mapping tools, deployment descriptors, rules, or capabilities to bind
resource reference entries to resources in the target operational
environment.

The _description_ deployment descriptor
elements and annotation elements provided by the Application Component
Provider or Application Assembler help the Deployer with this task.

=== Jakarta EE Product Provider’s Responsibilities

The Jakarta EE Product Provider has the following
responsibilities:

* Provide a deployment tool that allows the
Deployer to set and modify the entries of the application component’s
naming context.
* Implement the _java:comp_ , _java:module_ ,
_java:app_ and _java:global_ environment naming contexts, and provide
them to the application component instances at runtime. The naming
context must include all the entries declared by the Application
Component Provider, with their values supplied in the deployment
descriptor or set by the Deployer. The environment naming context must
allow the Deployer to create subcontexts if they are needed by an
application component. Certain entries in the naming context may have to
be initialized with the values of other entries, specifically when the
“lookup” facility is used. In this case, it is an error if there are any
circular dependencies between entries. Similarly, it is an error if
looking up the specified JNDI name results in a resource whose type is
not compatible with the entry being created. The deployment tool may
allow the deployer to correct either of these classes of errors and
continue the deployment.
* Ensure that, in the absence of any
properties specified by the application, the
_javax.naming.InitialContext_ implementation meets the requirements
described in this specification.
* Inject entries from the naming environment
into the application component, as specified by the deployment
descriptor or annotations on the application component classes.
* The container must ensure that the
application component instances have only read access to their naming
context. The container must throw the
_javax.naming.OperationNotSupportedException_ from all the methods of
the _javax.naming.Context_ interface that modify the environment naming
context and its subcontexts.

=== [[a751]]Simple Environment Entries

A simple environment entry is a configuration
parameter used to customize an application component’s business logic.
The environment entry values may be one of the following Java types:
_String_ , _Character_ , _Byte_ , _Short_ , _Integer_ , _Long_ ,
_Boolean_ , _Double_ , _Float_ , _Class_ , and any subclass of _Enum_ .

The following subsections describe the
responsibilities of each Jakarta EE Role.

=== Application Component Provider’s Responsibilities

This section describes the Application Component
Provider’s view of the application component’s environment, and defines
his or her responsibilities. It does so in three sections, the first
describing annotations for injecting environment entries, the second
describing the API for accessing environment entries, and the third
describing syntax for declaring the environment entries in a deployment
descriptor.

=== Injection of Simple Environment Entries

A field or a method of an application component
may be annotated with the _Resource_ annotation. The name and type of
the environment entry are as described above. Note that the container
will unbox the environment entry as required to match it to a primitive
type used for the injection field or method. The _authenticationType_
and _shareable_ elements of the _Resource_ annotation must not be
specified; simple environment entries are not shareable and do not
require authentication.

The following code example illustrates how an
application component uses annotations to declare environment entries.

=== // The maximum number of tax exemptions, configured by the Deployer.

@Resource int maxExemptions;

// The minimum number of tax exemptions,
configured by the Deployer.

@Resource int minExemptions;



public void setTaxInfo(int
numberOfExemptions,...)

 throws InvalidNumberOfExemptionsException \{

 ...

 // Use the environment entries to

 // customize business logic.

 if (numberOfExemptions > maxExemptions ||

 numberOfExemptions < minExemptions)

 throw new
InvalidNumberOfExemptionsException();

 ...

=== }

The following code example illustrates how an
environment entry can be assigned a value by referring to another entry,
potentially in a different namespace.

=== // an entry that gets its value from an application-wide entry

@Resource(lookup="java:app/env/timeout") int
timeout;

=== Programming Interfaces for Accessing Simple Environment Entries

In addition to the injection based approach
described above, an application component may access environment entries
dynamically. An application component instance locates the environment
naming context using the JNDI interfaces. An instance creates a
_javax.naming.InitialContext_ object by using the constructor with no
arguments, and looks up the naming environment via the _InitialContext_
under the name _java:comp/env_ . The application component’s environment
entries are stored directly in the environment naming context, or in its
direct or indirect subcontexts.

Environment entries have the Java programming
language type declared by the Application Component Provider in the
deployment descriptor.

The following code example illustrates how an
application component accesses its environment entries.

===  public void setTaxInfo(int numberOfExemptions,...)

 throws InvalidNumberOfExemptionsException \{

 ...

 // Obtain the application component’s

 // environment naming context.

 Context initCtx = new InitialContext();

 Context myEnv =
(Context)initCtx.lookup("java:comp/env");



 // Obtain the maximum number of tax exemptions

 // configured by the Deployer.

 Integer max =
(Integer)myEnv.lookup("maxExemptions");



 // Obtain the minimum number of tax exemptions

 // configured by the Deployer.

 Integer min =
(Integer)myEnv.lookup("minExemptions");



 // Use the environment entries to

 // customize business logic.

 if (numberOfExemptions > max.intValue() ||

 numberOfExemptions < min.intValue())

 throw new InvalidNumberOfExemptionsException();



 // Get some more environment entries. These
environment

 // entries are stored in subcontexts.

 String val1 =
(String)myEnv.lookup("foo/name1");

 Boolean val2 =
(Boolean)myEnv.lookup("foo/bar/name2");



 // The application component can also

 // lookup using full pathnames.

 Integer val3 =
(Integer)initCtx.lookup("java:comp/env/name3");

 Integer val4 =


(Integer)initCtx.lookup("java:comp/env/foo/name4");

 ...

=== }

=== Declaration of Simple Environment Entries

The Application Component Provider must declare
all the environment entries accessed from the application component’s
code. The environment entries are declared using either annotations on
the application component’s code, or using the _env-entry_ elements in
the deployment descriptor. Each _env-entry_ element describes a single
environment entry. The _env-entry_ element consists of an optional
description of the environment entry, the environment entry name, which
by default is relative to the _java:comp/env_ context, the expected Java
programming language type of the environment entry value (the type of
the object returned from the JNDI _lookup_ method), and an optional
environment entry value.

An environment entry is scoped to the
application component whose declaration contains the _env-entry_
element. This means that the environment entry is not accessible from
other application components at runtime, and that other application
components may define _env-entry_ elements with the same
_env-entry-name_ without causing a name conflict.

If the Application Component Provider provides a
value for an environment entry using the _env-entry-value_ element, the
value can be changed later by the Application Assembler or Deployer. The
value must be a string that is valid for the constructor of the
specified type that takes a single _String_ parameter, or in the case of
_Character_ , a single character.

The following example is the declaration of
environment entries used by the application component whose code was
illustrated in the previous subsection.

=== ...

<env-entry>

 <description>

 The maximum number of tax exemptions

 allowed to be set.

 </description>

 <env-entry-name>maxExemptions</env-entry-name>


<env-entry-type>java.lang.Integer</env-entry-type>

 <env-entry-value>15</env-entry-value>

</env-entry>

<env-entry>

 <description>

 The minimum number of tax exemptions allowed to
be set.

 </description>

 <env-entry-name>minExemptions</env-entry-name>


<env-entry-type>java.lang.Integer</env-entry-type>

 <env-entry-value>1</env-entry-value>

</env-entry>

<env-entry>

 <env-entry-name>foo/name1</env-entry-name>


<env-entry-type>java.lang.String</env-entry-type>

 <env-entry-value>value1</env-entry-value>

</env-entry>

<env-entry>

 <env-entry-name>foo/bar/name2</env-entry-name>


<env-entry-type>java.lang.Boolean</env-entry-type>

 <env-entry-value>true</env-entry-value>

</env-entry>

<env-entry>

 <description>Some description.</description>

 <env-entry-name>name3</env-entry-name>


<env-entry-type>java.lang.Integer</env-entry-type>

</env-entry>

<env-entry>

 <env-entry-name>foo/name4</env-entry-name>


<env-entry-type>java.lang.Integer</env-entry-type>

 <env-entry-value>10</env-entry-value>

</env-entry>

<env-entry>

 <env-entry-name>helperClass</env-entry-name>


<env-entry-type>java.lang.Class</env-entry-type>


<env-entry-value>com.acme.helper.Helper</env-entry-value>

</env-entry>

<env-entry>

 <env-entry-name>timeUnit</env-entry-name>


<env-entry-type>java.util.concurrent.TimeUnit</env-entry-type>


<env-entry-value>NANOSECONDS</env-entry-value>

</env-entry>

<env-entry>

 <env-entry-name>bar</env-entry-name>


<env-entry-type>java.lang.Integer</env-entry-type>


<lookup-name>java:app/env/appBar</lookup-name>

</env-entry>

=== ...

Injection of environment entries may also be
specified using the deployment descriptor, without need for Java
language annotations. The following example is the declaration of
environment entries corresponding to the earlier injection example.

=== ...

<env-entry>

 <description>

 The maximum number of tax exemptions

 allowed to be set.

 </description>

 <env-entry-name>

 com.example.PayrollService/maxExemptions

 </env-entry-name>


<env-entry-type>java.lang.Integer</env-entry-type>

 <env-entry-value>15</env-entry-value>

 <injection-target>

 <injection-target-class>

 com.example.PayrollService

 </injection-target-class>

 <injection-target-name>

 maxExemptions

 </injection-target-name>

 </injection-target>

</env-entry>

<env-entry>

 <description>

 The minimum number of tax exemptions

 allowed to be set.

 </description>

 <env-entry-name>

 com.example.PayrollService/minExemptions

 </env-entry-name>


<env-entry-type>java.lang.Integer</env-entry-type>

 <env-entry-value>1</env-entry-value>

 <injection-target>

 <injection-target-class>

 com.example.PayrollService

 </injection-target-class>

 <injection-target-name>

 minExemptions

 </injection-target-name>

 </injection-target>

</env-entry>



It’s often convenient to declare a field or
method as an injection target, but specify a default value in the code,
as illustrated in the following example.



// The maximum number of tax exemptions,
configured by the Deployer.

@Resource int maxExemptions = 4; // defaults to
4



To support this case, the container must only
inject a value for this resource if the deployer has specified a value
to override the default value. The _env-entry-value_ element in the
deployment descriptor is optional when an injection target is specified.
If the element is not specified, no value will be injected. In addition,
if the element is not specified, the named resource is not initialized
in the naming context; explicit lookups of the named resource will fail.

The deployment descriptor equivalent of the
_lookup_ element of the _@Resource_ annotation is _lookup-name_ . The
following deployment descriptor fragment is equivalent to the earlier
example that used _lookup_ .



<env-entry>


<env-entry-name>somePackage.SomeClass/timeout</env-entry-name>


<env-entry-type>java.lang.Integer</env-entry-type>

 <injection-target>

 <injection-target-class>

 somePackage.SomeClass

 </injection-target-class>


<injection-target-name>timeout</injection-target-name>

 </injection-target>


<lookup-name>java:app/env/timeout</lookup-name>

</env-entry>



It is an error for both the _env-entry-value_
and _lookup-name_ elements to be specified for a given _env-entry_
element. If either element exists, an eventual _lookup_ element of the
corresponding _Resource_ annotation (if any) must be ignored. In other
words, assignment of a value to an environment entry via a deployment
descriptor, either directly ( _env-entry-value_ ) or indirectly (
_lookup-name_ ), overrides any assignments made via annotations.

=== [[a936]]Enterprise JavaBeans™ (EJB) References

This section describes the programming and
deployment descriptor interfaces that allow the Application Component
Provider to refer to the homes of enterprise beans or to enterprise bean
instances using “logical” names called EJB references. The EJB
references are special entries in the application component’s naming
environment. The Deployer binds the EJB reference to the enterprise
bean’s business interface, no-interface view, or home interface in the
target operational environment.

The deployment descriptor also allows the
Application Assembler to link an EJB reference declared in one
application component to an enterprise bean contained in an ejb-jar file
in the same Jakarta EE application. The link is an instruction to the tools
used by the Deployer describing the binding of the EJB reference to the
business interface, no-interface view, or home interface of the
specified target enterprise bean. The same linking can also be specified
by the Application Component Provider using annotations in the source
code of the component.

The requirements in this section only apply to
Jakarta EE products that include an EJB container.

=== Application Component Provider’s Responsibilities

This subsection describes the Application
Component Provider’s view and responsibilities with respect to EJB
references. It does so in three sections, the first describing
annotations for injecting EJB references, the second describing the API
for accessing EJB references, and the third describing the syntax for
declaring the EJB references in a deployment descriptor

=== Injection of EJB Entries

A field or a method of an application component
may be annotated with the _EJB_ annotation. The _EJB_ annotation
represents a reference to an EJB session bean or entity bean. The
reference may be to a session bean’s business interface, to a session
bean’s no-interface view, or to the local or remote home interface of a
session bean or entity bean.

The following example illustrates how an
application component uses the EJB annotation to reference an instance
of an enterprise bean. The referenced bean is a stateful session bean.
The enterprise bean reference will have the name
_java:comp/env/com.example.ExampleBean/myCart_ in the naming context,
where _ExampleBean_ is the name of the class of the referencing bean and
_com.acme.example_ is its package. The target of the reference is not
named and must be resolved by the Deployer, unless there is only one
session bean component within the application that exposes a client view
type that matches the EJB reference.



package com.acme.example;



@Stateless public class ExampleBean
implements Example \{

 ...

 @EJB private ShoppingCart myCart;

 ...

}



The following example illustrates use of almost
all elements of the _EJB_ annotation.

=== @EJB(

 name = "ejb/shopping-cart",

 beanName = "cart1”,

 beanInterface = ShoppingCart.class,

 description = "The shopping cart for this
application"

)

private ShoppingCart myCart;



As an alternative to _beanName_ , a reference
to an EJB can use the global JNDI name for that EJB, or any of the other
names mandated by the EJB specifications, by means of the _lookup_
annotation element. The following example uses a JNDI name in the
application namespace.

=== @EJB(

 lookup="java:app/cartModule/ShoppingCart",

 description = "The shopping cart for this
application"

)

private ShoppingCart myOtherCart;



If the _ShoppingCart_ bean were instead
written to the EJB 2.x client view, the EJB reference would be to the
bean’s home interface. For example:



@EJB(

 name="ejb/shopping-cart",

 beanInterface=ShoppingCartHome.class,

 beanName="cart1",

 description="The shopping cart for this
application"

)

private ShoppingCartHome myCartHome;



If the _ShoppingCart_ bean were instead
written to the no-interface client view and implemented by bean class
_ShoppingCartBean.class_ , the EJB reference would have type
_ShoppingCartBean.class_ . For example:



@EJB(

 name="ejb/shopping-cart",

 beanInterface=ShoppingCartBean.class,

 beanName="cart1",

 description="The shopping cart for this
application"

)

private ShoppingCartBean myCart;

=== Programming Interfaces for EJB References

The Application Component Provider may use EJB
references to locate the business interface, no-interface view, or home
interface of an enterprise bean as follows.

* Assign an entry in the application component’s
environment to the reference. (See subsection
link:#a1011[See Declaration of EJB
References] for information on how EJB references are declared in the
deployment descriptor.)
* This specification recommends, but does not
require, that references to enterprise beans be organized in the _ejb_
subcontext of the application component’s environment (that is, in the
_java:comp/env/ejb_ JNDI context). Note that enterprise bean references
declared via annotations will not, by default, be in any subcontext.
* Look up the business interface, no-interface
view, or home interface of the referenced enterprise bean in the
application component’s environment using JNDI.

The following example illustrates how an
application component uses an EJB reference to locate the home interface
of an enterprise bean.

=== public void changePhoneNumber(...) \{

 ...

 // Obtain the default initial JNDI context.

 Context initCtx = new InitialContext();



 // Look up the home interface of the
EmployeeRecord

 // enterprise bean in the environment.

 Object result =
initCtx.lookup("java:comp/env/ejb/EmplRecord");



 // Convert the result to the proper type.

 EmployeeRecordHome emplRecordHome =
(EmployeeRecordHome)

 javax.rmi.PortableRemoteObject.narrow(result,

 EmployeeRecordHome.class);

 ...

===  }

In the example, the Application Component
Provider assigned the environment entry _ejb/EmplRecord_ as the EJB
reference name to refer to the remote home interface of an enterprise
bean.

=== [[a1011]]Declaration of EJB References

Although the EJB reference is an entry in the
application component’s environment, the Application Component Provider
must not use a _env-entry_ element to declare it. Instead, the
Application Component Provider must declare all the EJB references using
either annotations on the application component’s code or the _ejb-ref_
or _ejb-local-ref_ elements of the deployment descriptor. This allows
the consumer of the application component’s JAR file (the Application
Assembler or Deployer) to discover all the EJB references used by the
application component. Deployment descriptor entries may also be used to
specify injection of an EJB reference into an application component.

Each _ejb-ref_ or _ejb-local-ref_ element
describes the interface requirements that the referencing application
component has for the referenced enterprise bean. The _ejb-ref_ element
is used for referencing an enterprise bean that is accessed through its
remote business interface or remote home and component interfaces. The
_ejb-local-ref_ element is used for referencing an enterprise bean that
is accessed through its local business interface, no-interface view, or
local home and component interfaces. The _ejb-ref_ element contains a
_description_ element and the _ejb-ref-name_ , _ejb-ref-type_ , _home_ ,
and _remote_ elements. The _ejb-local-ref_ element contains a
_description_ element and the _ejb-ref-name_ , _ejb-ref-type_ ,
_local-home_ , and _local_ elements

The _ejb-ref-name_ element specifies the EJB
reference name. Its value is the environment entry name used in the
application component code. The optional _ejb-ref-type_ element
specifies the expected type of the enterprise bean. Its value must be
either _Entity_ or _Session_ . The _home_ and _remote_ or _local-home_
and _local_ elements specify the expected Java programming language
types of the referenced enterprise bean’s interface(s). If the reference
is to an EJB 2.x remote client view interface, the _home_ element is
required. Likewise, if the reference is to an EJB 2.x local client view
interface, the _local-home_ element is required. The _remote_ element of
the _ejb-ref_ element refers to either the business interface type or
the component interface, depending on whether the reference is to a
bean’s EJB 3.x or EJB 2.x remote client view. Likewise, the _local_
element of the _ejb-local-ref_ element refers to either the business
interface type, bean class type, or the component interface type,
depending on whether the reference is to a bean’s EJB 3.x local business
interface, no-interface view, or EJB 2.x local client view respectively.

An EJB reference is scoped to the application
component whose declaration contains the _ejb-ref_ or _ejb-local-ref_
element. This means that the EJB reference is not accessible from other
application components at runtime and that other application components
may define _ejb-ref_ or _ejb-local-ref_ elements with the same
_ejb-ref-name_ without causing a name conflict.

The lookup-name element specifies the JNDI
name of an environment entry that provides a value for the reference.

The following example illustrates the
declaration of EJB references in the deployment descriptor.

=== ...

<ejb-ref>

 <description>

 This is a reference to the entity bean that

 encapsulates access to employee records.

 </description>

 <ejb-ref-name>ejb/EmplRecord</ejb-ref-name>

 <ejb-ref-type>Entity</ejb-ref-type>

 <home>com.wombat.empl.EmployeeRecordHome</home>

 <remote>com.wombat.empl.EmployeeRecord</remote>

</ejb-ref>



<ejb-ref>

 <ejb-ref-name>ejb/Payroll</ejb-ref-name>

 <ejb-ref-type>Entity</ejb-ref-type>

 <home>com.aardvark.payroll.PayrollHome</home>

 <remote>com.aardvark.payroll.Payroll</remote>

</ejb-ref>



<ejb-ref>

 <ejb-ref-name>ejb/PensionPlan</ejb-ref-name>

 <ejb-ref-type>Session</ejb-ref-type>

 <home>com.wombat.empl.PensionPlanHome</home>

 <remote>com.wombat.empl.PensionPlan</remote>


<lookup-name>java:global/personnel/retirement/PensionPlan</lookup-name>

</ejb-ref>

=== ...

=== Application Assembler’s Responsibilities

The Application Assembler can use the _ejb-link_
element in the deployment descriptor to link an EJB reference to a
target enterprise bean.

The Application Assembler specifies the link to
an enterprise bean as follows:

* The Application Assembler uses the optional
_ejb-link_ element of the _ejb-ref_ or _ejb-local-ref_ element of the
referencing application component. The value of the _ejb-link_ element
is the name of the target enterprise bean. This is the name as defined
by the metadata annotation (or default) on the bean class or in the
_ejb-name_ element for the target enterprise bean. The target enterprise
bean can be in any ejb-jar file or war file in the same Jakarta EE
application as the referencing application component.
* Alternatively, to avoid the need to rename
enterprise beans to have unique names within an entire Jakarta EE
application, the Application Assembler may use either of the following
two syntaxes in the _ejb-link_ element of the referencing application
component.
* The Application Assembler specifies the
module name of the ejb-jar file or war file containing the referenced
enterprise bean and appends the ejb-name of the target bean separated by
“/”. The module name is the base name of the bundle with no filename
extension, unless specified in the deployment descriptor.
* The Application Assembler specifies the
path name of the ejb-jar file containing the referenced enterprise bean
and appends the _ejb-name_ of the target bean separated from the path
name by “ _#_ ”. The path name is relative to the referencing
application component JAR file. In this manner, multiple beans with the
same _ejb-name_ may be uniquely identified when the Application
Assembler cannot change ejb-names.
* Alternatively to the use of _ejb-link_ , the
Application Assembler may use the _lookup-name_ element to reference the
target EJB component by means of one of its JNDI names. It is an error
for both _ejb-link_ and _lookup-name_ to appear inside an _ejb-ref_
element.
* The Application Assembler must ensure that
the target enterprise bean is type-compatible with the declared EJB
reference. This means that the target enterprise bean must be of the
type indicated in the _ejb-ref-type_ element, if present, and that the
business interface, no-interface view, or home and remote interfaces of
the target enterprise bean must be Java type-compatible with the type
declared in the EJB reference.

The following example illustrates the use of the
_ejb-link_ element in the deployment descriptor. The enterprise bean
reference should be satisfied by the bean named _EmployeeRecord_ . The
_EmployeeRecord_ enterprise bean may be packaged in the same module as
the component making this reference, or it may be packaged in another
module within the same Jakarta EE application as the component making this
reference.

=== ...

<ejb-ref>

 <description>

 This is a reference to the entity bean that

 encapsulates access to employee records. It

 has been linked to the entity bean named

 EmployeeRecord in this application.

 </description>

 <ejb-ref-name>ejb/EmplRecord</ejb-ref-name>

 <ejb-ref-type>Entity</ejb-ref-type>

 <home>com.wombat.empl.EmployeeRecordHome</home>

 <remote>com.wombat.empl.EmployeeRecord</remote>

 <ejb-link>EmployeeRecord</ejb-link>

</ejb-ref>

=== ...

The following example illustrates using the
_ejb-link_ element to indicate an enterprise bean reference to the
_ProductEJB_ enterprise bean that is in the same Jakarta EE application
unit but in a different ejb-jar file.

=== ...

<ejb-ref>

 <description>

 This is a reference to the entity bean that

 encapsulates access to a product. It

 has been linked to the entity bean named

 ProductEJB in the product.jar file in this

 application.

 </description>

 <ejb-ref-name>ejb/Product</ejb-ref-name>

 <ejb-ref-type>Entity</ejb-ref-type>

 <home>com.acme.products.ProductHome</home>

 <remote>com.acme.products.Product</remote>


<ejb-link>../products/product.jar#ProductEJB</ejb-link>

</ejb-ref>

=== ...

The following example illustrates using the
_ejb-link_ element to indicate an enterprise bean reference to the
_ShoppingCart_ enterprise bean that is in the same Jakarta EE application
unit but in a different ejb-jar file. The reference was originally
declared in the application component’s code using an annotation. The
Assembler provides only the link to the bean.

=== ...

<ejb-ref>


<ejb-ref-name>ShoppingService/myCart</ejb-ref-name>


<ejb-link>../products/product.jar#ShoppingCart</ejb-link>

</ejb-ref>

=== ...

The same effect can be obtained by using the
_lookup-name_ element instead, using an appropriate JNDI name for the
target bean.



...

<ejb-ref>


<ejb-ref-name>ShoppingService/myCart</ejb-ref-name>


<lookup-name>java:app/products/ShoppingCart</lookup-name>

</ejb-ref>

...

=== Deployer’s Responsibilities

The Deployer is responsible for the following:

* The Deployer must ensure that all the declared
EJB references are bound to the business interfaces, no-interface views,
or home interfaces of enterprise beans that exist in the operational
environment. The Deployer may use, for example, the JNDI _LinkRef_
mechanism to create a symbolic link to the actual JNDI name of the
target enterprise bean.
* The Deployer must ensure that the target
enterprise bean is type-compatible with the types declared for the EJB
reference. This means that the target enterprise bean must be of the
type indicated in the _ejb-ref-type_ element or specified via the _EJB_
annotation, and that the business interface, no-interface view, or home
and remote interfaces of the target enterprise bean must be Java
type-compatible with the type declared in the EJB reference (if
specified).
* If an EJB reference declaration includes the
_ejb-link_ element, the Deployer should bind the enterprise bean
reference to the enterprise bean specified as the link’s target. If an
EJB annotation includes the _lookup_ element or the EJB reference
declaration includes the _lookup-name_ element, the Deployer should bind
the enterprise bean reference to the enterprise bean specified as the
target of the lookup. It is an error for an EJB reference declaration to
include both an _ejb-link_ and a _lookup-name_ element.

The following example illustrates the use of
the _lookup-name_ element to bind an _ejb-ref_ to a target enterprise
bean in the operational environment. The reference was originally
declared in the bean’s code using an annotation. The target enterprise
bean has _ejb-name_ _ShoppingCart_ and is deployed in the stand-alone
module _products.jar_ .

...

<ejb-ref>


<ejb-ref-name>ShoppingService/myCart</ejb-ref-name>


<lookup-name>java:global/products/ShoppingCart</lookup-name>

</ejb-ref>

=== Jakarta EE Product Provider’s Responsibilities

The Jakarta EE Product Provider must provide the
deployment tools that allow the Deployer to perform the tasks described
in the previous subsection. The deployment tools provided by the Jakarta EE
Product Provider must be able to process the information supplied in
class file annotations and in the _ejb-ref_ and _ejb-local-ref_ elements
in the deployment descriptor.

At the minimum, the tools must be able to:

* Preserve the application assembly information
in annotations or in the _ejb-link_ elements by binding an EJB reference
to the business interface, no-interface view, or home interface of the
specified target enterprise bean.
* Inform the Deployer of any unresolved EJB
references, and allow him or her to resolve an EJB reference by binding
it to a specified compatible target enterprise bean.

=== [[a1118]]Web Service References

A web service reference is similar to an
Enterprise JavaBeans reference, but is used to reference a web service.
Web service references are fully specified in the Web Service
specification and the JAX-WS specification.

=== [[a1120]]Resource Manager Connection Factory References

A resource manager connection factory is an
object that is used to create connections to a resource manager. For
example, an object that implements the _javax.sql.DataSource_ interface
is a resource manager connection factory for _java.sql.Connection_
objects that implement connections to a database management system.

This section describes the application component
programming and deployment descriptor interfaces that allow the
application component code to refer to resource factories using logical
names called resource manager connection factory references. The
resource manager connection factory references are special entries in
the application component’s environment. The Deployer binds the resource
manager connection factory references to the actual resource manager
connection factories that exist in the target operational environment.
Because these resource manager connection factories allow the Container
to affect resource management, the connections acquired through the
resource manager connection factory references are called managed
resources (for example, these resource manager connection factories
allow the Container to implement connection pooling and automatic
enlistment of the connection with a transaction).

Resource manager connection factory objects
accessed through the naming environment are only valid within the
component instance that performed the lookup. See the individual
component specifications for additional restrictions that may apply.

=== Application Component Provider’s Responsibilities

This subsection describes the Application
Component Provider’s view of locating resource factories and defines his
or her responsibilities. It does so in three sections, the first
describing the annotations used to inject resource manager connection
factory references, the second describing the API for accessing resource
manager connection factory references, and the third describing the
syntax for declaring the factory references in a deployment descriptor

=== Injection of Resource Manager Connection Factory References

A field or a method of an application component
may be annotated with the _Resource_ annotation. The name and type of
the factory are as described above. The _authenticationType_ and
_shareable_ elements of the _Resource_ annotation may be used to control
the type of authentication desired for the resource and the shareability
of connection acquired from the factory, as described in the following
sections.

The following code example illustrates how an
application component uses annotations to declare resource manager
connection factory references.

=== // The employee database.

@Resource javax.sql.DataSource employeeAppDB;

public void changePhoneNumber(...) \{

 ...

 // Invoke factory to obtain a resource. The
security

 // principal for the resource is not given,
and

 // therefore it will be configured by the
Deployer.

 java.sql.Connection con =
employeeAppDB.getConnection();

 ...

=== }

It is possible to specify as part of the
_@Resource_ annotation the JNDI name of an entry to which the resource
being defined will be bound.

=== // The customer database, looked up in the application environment.

@Resource(lookup="java:app/env/customerDB")

javax.sql.DataSource customerAppDB;



The data source object being looked up in the
previous example may have been declared as follows.



@Resource(name="java:app/env/customerDB",

 type=javax.sql.DataSource.class)

public class AnApplicationClass \{

 ...

}



From a practical standpoint, declaring a
commonly used data source at the application level and referring to it
using lookup from multiple components may simplify the task of deploying
the application, since now the Deployer will have to perform a single
binding operation for the application-level resource, instead of
multiple ones. The task can be further simplified by using a data source
resource definition, see
link:#a1688[See DataSource Resource
Definition]”. Of course, nothing prevents the Deployer from separately
binding each data source reference if necessary.

=== Programming Interfaces for Resource Manager Connection Factory References

The Application Component Provider may use
resource manager connection factory references to obtain connections to
resources as follows.

* Assign an entry in the application component’s
naming environment to the resource manager connection factory reference.
(See subsection link:#a1183[See
Declaration of Resource Manager Connection Factory References in
Deployment Descriptor] for information on how resource manager
connection factory references are declared in the deployment
descriptor.)
* This specification recommends, but does not
require, that all resource manager connection factory references be
organized in the subcontexts of the application component’s environment,
using a different subcontext for each resource manager type. For
example, all JDBC™ DataSource references should be declared in the
_java:comp/env/jdbc_ subcontext, all JMS connection factories in the
_java:comp/env/jms_ subcontext, all JavaMail connection factories in the
_java:comp/env/mail_ subcontext, and all URL connection factories in the
_java:comp/env/url_ subcontext. Note that resource manager connection
factory references declared via annotations will not, by default, appear
in any subcontext.
* Lookup the resource manager connection factory
object in the application component’s environment using the JNDI
interface.
* Invoke the appropriate method on the resource
manager connection factory object to obtain a connection to the
resource. The factory method is specific to the resource type. It is
possible to obtain multiple connections by calling the factory object
multiple times.

The Application Component Provider can control
the shareability of the connections acquired from the resource manager
connection factory. By default, connections to a resource manager are
shareable across other application components in the application that
use the same resource in the same transaction context. The Application
Component Provider can specify that connections obtained from a resource
manager connection factory reference are not shareable by specifying the
value of the _shareable_ annotation element to _false_ or the
_res-sharing-scope_ deployment descriptor element to be _Unshareable_ .
The sharing of connections to a resource manager allows the container to
optimize the use of connections and enables the container’s use of local
transaction optimizations.

The Application Component Provider has two
choices with respect to dealing with associating a principal with the
resource manager access:

* Allow the Deployer to set up principal mapping
or resource manager sign on information. In this case, the application
component code invokes a resource manager connection factory method that
has no security-related parameters.
* Sign on to the resource from the application
component code. In this case, the application component invokes the
appropriate resource manager connection factory method that takes the
sign on information as method parameters.

The Application Component Provider uses the
_authenticationType_ annotation element or the _res-auth_ deployment
descriptor element to indicate which of the two resource authentication
approaches is used.

We expect that the first form (that is letting
the Deployer set up the resource sign on information) will be the
approach used by most application components.

The following code sample illustrates obtaining
a JDBC connection.

===  public void changePhoneNumber(...) \{

 ...



 // obtain the initial JNDI context

 Context initCtx = new InitialContext();



 // perform JNDI lookup to obtain resource
manager

 // connection factory

 javax.sql.DataSource ds =
(javax.sql.DataSource)


initCtx.lookup("java:comp/env/jdbc/EmployeeAppDB");



 // Invoke factory to obtain a resource. The
security

 // principal for the resource is not given, and

 // therefore it will be configured by the
Deployer.

 java.sql.Connection con = ds.getConnection();

 ...

===  }

=== [[a1183]]Declaration of Resource Manager Connection Factory References in Deployment Descriptor

Although a resource manager connection factory
reference is an entry in the application component’s environment, the
Application Component Provider must not use an _env-entry_ element to
declare it.

Instead, the Application Component Provider must
declare all the resource manager connection factory references using
either annotations on the application component’s code or in the
deployment descriptor using the _resource-ref_ elements. This allows the
consumer of the application component’s JAR file (the Application
Assembler or Deployer) to discover all the resource manager connection
factory references used by an application component. Deployment
descriptor entries may also be used to specify injection of a resource
manager connection factory reference into an application component.

Each _resource-ref_ element describes a single
resource manager connection factory reference. The _resource-ref_
element consists of the _description_ element, the mandatory
_res-ref-name_ element, and the optional _res-sharing-scope_ ,
_res-type_ , and _res-auth_ elements. The _res-ref-name_ element
contains the name of the environment entry used in the application
component’s code. The name of the environment entry is relative to the
_java:comp/env_ context (for example, the name should be
_jdbc/EmployeeAppDB_ rather than _java:comp/env/jdbc/EmployeeAppDB_ ).
The _res-type_ element contains the Java programming language type of
the resource manager connection factory that the application component
code expects. The _res-type_ element is optional if an injection target
is specified for this resource; in this case the _res-type_ defaults to
the type of the injection target. The _res-auth_ element indicates
whether the application component code performs resource sign on
programmatically, or whether the container signs on to the resource
based on the principal mapping information supplied by the Deployer. The
Application Component Provider indicates the sign on responsibility by
setting the value of the _res-auth_ element to _Application_ or
_Container_ . If not specified, the default is _Container_ . The
_res-sharing-scope_ element indicates whether connections to the
resource manager obtained through the given resource manager connection
factory reference can be shared or whether connections are unshareable.
The value of the _res-sharing-scope_ element is _Shareable_ or
_Unshareable_ . If the _res-sharing-scope_ element is not specified,
connections are assumed to be shareable.

A resource manager connection factory reference
is scoped to the application component whose declaration contains the
_resource-ref_ element. This means that the resource manager connection
factory reference is not accessible from other application components at
runtime, and that other application components may define _resource-ref_
elements with the same _res-ref-name_ without causing a name conflict.

The type declaration allows the Deployer to
identify the type of the resource manager connection factory.

Note that the indicated type is the Java
programming language type of the resource manager connection factory,
not the type of the connection.

The following example is the declaration of the
resource reference used by the application component illustrated in the
previous subsection.

=== ...

<resource-ref>

 <description>

 A data source for the database in which

 the EmployeeService enterprise bean will

 record a log of all transactions.

 </description>

 <res-ref-name>jdbc/EmployeeAppDB</res-ref-name>

 <res-type>javax.sql.DataSource</res-type>

 <res-auth>Container</res-auth>


<res-sharing-scope>Shareable</res-sharing-scope>

</resource-ref>



The following example modifies the previous
one by linking the resource reference being defined to another one,
using a well-known JNDI name for the latter.



<resource-ref>

<res-ref-name>jdbc/EmployeeAppDB</res-ref-name>

 <res-type>javax.sql.DataSource</res-type>

 <res-auth>Container</res-auth>


<res-sharing-scope>Shareable</res-sharing-scope>


<lookup-name>java:app/env/TheEmployeeDB</lookup-name>

</resource-ref>

=== Standard Resource Manager Connection Factory Types

The Application Component Provider must use the
_javax.sql.DataSource_ resource manager connection factory type for
obtaining JDBC API connections.

The Application Component Provider must use the
_javax.jms.ConnectionFactory_ , the _javax.jms.QueueConnectionFactory_ ,
or the _javax.jms.TopicConnectionFactory_ for obtaining JMS connections.

The Application Component Provider must use the
_javax.mail.Session_ resource manager connection factory type for
obtaining JavaMail API connections.

The Application Component Provider must use the
_java.net.URL_ resource manager connection factory type for obtaining
URL connections.

It is recommended that the Application Component
Provider name JDBC API data sources in the _java:comp/env/jdbc_
subcontext, all JMS connection factories in the _java:comp/env/jms_
subcontext, all JavaMail API connection factories in the
_java:comp/env/mail_ subcontext, and all URL connection factories in the
_java:comp/env/url_ subcontext. Note that resource manager connection
factory references declared via annotations will not, by default, appear
in any subcontext.

The Jakarta EE Connector Architecture allows an
application component to use the annotation or API described in this
section to obtain resource objects that provide access to additional
back-end systems.

=== Deployer’s Responsibilities

The Deployer uses deployment tools to bind the
resource manager connection factory references to the actual resource
factories configured in the target operational environment.

The Deployer must perform the following tasks
for each resource manager connection factory reference declared in the
deployment descriptor:

* Bind the resource manager connection factory
reference to a resource manager connection factory that exists in the
operational environment. The Deployer may use, for example, the JNDI
_LinkRef_ mechanism to create a symbolic link to the actual JNDI name of
the resource manager connection factory. The resource manager connection
factory type must be compatible with the type declared in the source
code or in the _res-type_ element. If the resource manager connection
factory references includes a _lookup_ annotation element or a
_lookup-name_ deployment descriptor element, the Deployer may choose
whether to honor it and have the corresponding lookup be performed, or
override it with a binding of his or her own choosing.
* Provide any additional configuration
information that the resource manager needs for opening and managing the
resource. The configuration mechanism is resource manager specific, and
is beyond the scope of this specification.
* If the value of the _Resource_ annotation
_authenticationType_ element is _AuthenticationType.CONTAINER_ or the
deployment descriptor’s _res-auth_ element is _Container_ , the Deployer
is responsible for configuring the sign on information for the resource
manager. This is performed in a manner specific to the container and
resource manager; it is beyond the scope of this specification.

For example, if principals must be mapped from
the security domain and principal realm used at the application
component level to the security domain and principal realm of the
resource manager, the Deployer or System Administrator must define the
mapping. The mapping is performed in a manner specific to the container
and resource manager; it is beyond the scope of this specification.

=== Jakarta EE Product Provider’s Responsibilities

The Jakarta EE Product Provider is responsible for
the following:

* Provide the deployment tools that allow the
Deployer to perform the tasks described in the previous subsection.
* Provide the implementation of the resource
manager connection factory classes that are required by this
specification.
* If the Application Component Provider sets the
_authenticationType_ element of the _Resource_ annotation to
_AuthenticationType.APPLICATION_ or the _res-auth_ of a resource
reference to _Application_ , the container must allow the application
component to perform explicit programmatic sign on using the resource
manager’s API.
* If the Application Component Provider sets
the _shareable_ element of the _Resource_ annotation to _false_ or sets
the _res-sharing-scope_ of a resource manager connection factory
reference to _Unshareable_ , the container must not attempt to share the
connections obtained from the resource manager connection factory
referencelink:#a3659[12].
* The container must provide tools that allow
the Deployer to set up resource sign on information for the resource
manager references whose _authenticationType_ is set to
_AuthenticationType.CONTAINER_ or whose _res-auth_ element is set to
_Container_ . The minimum requirement is that the Deployer must be able
to specify the username/password information for each resource manager
connection factory reference declared by the application component, and
the container must be able to use the username/password combination for
user authentication when obtaining a connection by invoking the resource
manager connection factory.

Although not required by this specification, we
expect that containers will support some form of a single sign on
mechanism that spans the application server and the resource managers.
The container will allow the Deployer to set up the resources such that
the principal can be propagated (directly or through principal mapping)
to a resource manager, if required by the application.

While not required by this specification, most
Jakarta EE products will provide the following features:

* A tool to allow the System Administrator to
add, remove, and configure a resource manager for the Jakarta EE Server.
* A mechanism to pool resources for the
application components and otherwise manage the use of resources by the
container. The pooling must be transparent to the application
components.

=== System Administrator’s Responsibilities

The System Administrator is typically
responsible for the following:

* Add, remove, and configure resource managers
in the Jakarta EE Server environment.

In some scenarios, these tasks can be performed
by the Deployer.

=== [[a1242]]Resource Environment References

This section describes the programming and
deployment descriptor interfaces that allow the Application Component
Provider to refer to administered objects that are associated with a
resource (for example, a Connector CCI _InteractionSpec_ instance) by
using “logical” names called resource environment references. The
resource environment references are special entries in the application
component’s environment. The Deployer binds the resource environment
references to administered objects in the target operational
environment.

=== Application Component Provider’s Responsibilities

This subsection describes the Application
Component Provider’s view and responsibilities with respect to resource
environment references.

=== Injection of Resource Environment References

A field or a method of an application component
may be annotated with the _Resource_ annotation to request injection of
a resouce environment reference. The name and type of the resource
environment reference are as described earlier. The _authenticationType_
and _shareable_ elements of the _Resource_ annotation must not be
specified; resource environment entries are not shareable and do not
require authentication. The use of the _Resource_ annotation to declare
a resource environment reference differs from the use of the _Resource_
annotation to declare other environment references only in that the type
of a resource environment reference is not one of the Java language
types used for other environment references.

=== Resource Environment Reference Programming Interfaces

The Application Component Provider may use
resource environment references to locate administered objects that are
associated with resources as follows.

* Assign an entry in the application component’s
environment to the reference. (See subsection
link:#a1253[See Declaration of Resource
Environment References in Deployment Descriptor] for information on how
resource environment references are declared in the deployment
descriptor.)
* This specification recommends, but does not
require, that all resource environment references be organized in the
appropriate subcontext of the component’s environment for the resource
type. Note that resource environment references declared via annotations
will not, by default, appear in any subcontext.
* Look up the administered object in the
application component’s environment using JNDI.

=== [[a1253]]Declaration of Resource Environment References in Deployment Descriptor

Although the resource environment reference is
an entry in the application component’s environment, the Application
Component Provider must not use a _env-entry_ element to declare it.
Instead, the Application Component Provider must declare all references
to administered objects associated with resources using either
annotations on the application component’s code or the
_resource-env-ref_ elements of the deployment descriptor. This allows
the application component’s JAR file consumer to discover all the
resource environment references used by the application component.
Deployment descriptor entries may also be used to specify injection of a
resource environment reference into an application component.

Each _resource-env-ref_ element describes the
requirements that the referencing application component has for the
referenced administered object. The _resource-env-ref_ element contains
optional _description_ and _resource-env-ref-type_ elements and the
mandatory _resource-env-ref-name_ element. The _resource-env-ref-type_
element is optional if an injection target is specified for this
resource; in this case the _resource-env-ref-type_ defaults to the type
of the injection target.

The _resource-env-ref-name_ element specifies
the resource environment reference name. Its value is the environment
entry name used in the application component code. The name of the
resource environment reference is relative to the _java:comp/env_
context. The _resource-env-ref-type_ element specifies the expected type
of the referenced object.

A resource environment reference is scoped to
the application component whose declaration contains the
_resource-env-ref_ element. This means that the resource environment
reference is not accessible to other application components at runtime,
and that other application components may define _resource-env-ref_
elements with the same _resource-env-ref-name_ without causing a name
conflict.

A resource environment reference may specify a
_lookup-name_ to link the reference being defined to another one via a
JNDI name.

=== Deployer’s Responsibilities

The Deployer is responsible for the following:

* The Deployer must ensure that all the declared
resource environment references are bound to administered objects that
exist in the operational environment. The Deployer may use, for example,
the JNDI _LinkRef_ mechanism to create a symbolic link to the actual
JNDI name of the target object. The Deployer may override the linkage
preferences of a resource environment reference that includes a _lookup_
annotation element or _lookup-name_ deployment descriptor element.
* The Deployer must ensure that the target
object is type-compatible with the type declared for the resource
environment reference. This means that the target object must be of the
type indicated in the _Resource_ annotation or the
_resource-env-ref-type_ element.

=== Jakarta EE Product Provider’s Responsibilities

The Jakarta EE Product Provider must provide the
deployment tools that allow the Deployer to perform the tasks described
in the previous subsection. The deployment tools provided by the Jakarta EE
Product Provider must be able to process the information supplied in the
class file annotations and the _resource-env-ref_ elements in the
deployment descriptor.

At the minimum, the tools must be able to inform
the Deployer of any unresolved resource environment references, and
allow him or her to resolve a resource environment reference by binding
it to a specified compatible target object in the environment.

=== [[a1266]]Message Destination References

This section describes the programming and
deployment descriptor interfaces that allow the Application Component
Provider to refer to message destination objects by using “logical”
names called message destination references. Message destination
references are special entries in the application component’s
environment. The Deployer binds the message destination references to
administered message destinations in the target operational environment.

The requirements in this section only apply to
Jakarta EE products that include support for JMS.

=== Application Component Provider’s Responsibilities

This subsection describes the Application
Component Provider’s view and responsibilities with respect to message
destination references.

=== Injection of Message Destination References

A field or a method of an application component
may be annotated with the _Resource_ annotation to request injection of
a message destination reference. The name and type of the resource
environment reference are as described earlier. The _authenticationType_
and _shareable_ elements of the _Resource_ annotation must not be
specified; message destination references are not shareable and do not
require authentication.

Note that when using the _Resource_ annotation
to declare a message destination reference it is not possible to link
the reference to other references to the same message destination or to
specify whether the message destination is used to produce or consume
messages. The deployment descriptor entries described later do provide a
way to associate many message destination references with a single
message destination and to specify whether each message destination
reference is used to produce, consume, or both produce and consume
messages, so that the entire message flow of an application may be
specified. The Application Assembler may use these message destination
links to link together message destination references that have been
declared using the _Resource_ annotation. A message destination
reference declared via the _Resource_ annotation is assumed to be used
to both produce and consume messages; this default may be overridden
using a deployment descriptor entry.

The following example illustrates how an
application component uses the Resource annotation to request injection
of a message destination reference.

@Resource javax.jms.Queue stockQueue;

The following example illustrates how a
message destination reference can be linked to another one by specifying
its JNDI name, perhaps in a different namespace, as a value for the
lookup element.



@Resource(lookup="java:app/env/TheOrderQueue")

javax.jms.Queue orderQueue;

=== Message Destination Reference Programming Interfaces

The Application Component Provider may use
message destination references to locate message destinations, as
follows.

* Assign an entry in the application
component’s environment to the reference. (See subsection
link:#a1295[See Declaration of Message
Destination References in Deployment Descriptor] for information on how
message destination references are declared in the deployment
descriptor.)
* This specification recommends, but does not
require, that all message destination references be organized in the
appropriate subcontext of the component’s environment for the resource
type (for example, in the _java:comp/env/jms_ JNDI context for JMS
Destinations). Note that message destination references declared via
annotations will not, by default, appear in any subcontext.
* Look up the administered object in the
application component’s environment using JNDI.

The following example illustrates how an
application component uses a message destination reference to locate a
JMS Destination.

=== // Obtain the default initial JNDI context.

Context initCtx = new InitialContext();



// Look up the JMS StockQueue in the
environment.

Object result =
initCtx.lookup("java:comp/env/jms/StockQueue");



// Convert the result to the proper type.

=== javax.jms.Queue queue = (javax.jms.Queue)result;

In the example, the Application Component
Provider assigned the environment entry _jms/StockQueue_ as the message
destination reference name to refer to a JMS queue.

=== [[a1295]]Declaration of Message Destination References in Deployment Descriptor

Although the message destination reference is
an entry in the application component’s environment, the Application
Component Provider must not use a _env-entry_ element to declare it.
Instead, the Application Component Provider should declare all
references to message destinations using either the _Resource_
annotation in the application component’s code or the
_message-destination-ref_ elements of the deployment descriptor. This
allows the application component’s JAR file consumer to discover all the
message destination references used by the application component.
Deployment descriptor entries may also be used to specify injection of a
message destination reference into an application component.

Each _message-destination-ref_ element
describes the requirements that the referencing application component
has for the referenced destination. The _message-destination-ref_
element contains optional _description_ , _message-destination-type_ ,
and _message-destination-usage_ elements and the mandatory
_message-destination-ref-name_ element.

The _message-destination-ref-name_ element
specifies the message destination reference name. Its value is the
environment entry name used in the application component code. By
default, the name of the message destination reference is relative to
the _java:comp/env_ context (for example, the name should be
_jms/StockQueue_ rather than _java:comp/env/jms/StockQueue_ ). The
_message-destination-type_ element specifies the expected type of the
referenced destination. For example, in the case of a JMS Destination,
its value might be _javax.jms.Queue_ . The _message-destination-type_
element is optional if an injection target is specified for this message
destination reference; in this case the _message-destination-type_
defaults to the type of the injection target. The
_message-destination-usage_ element specifies whether messages are
consumed from the message destination, produced for the destination, or
both. If not specified, messages are assumed to be both consumed and
produced.

A message destination reference is scoped to
the application component whose declaration contains the
_message-destination-ref_ element. This means that the message
destination reference is not accessible to other application components
at runtime, and that other application components may define
_message-destination-ref_ elements with the same
_message-destination-ref-name_ without causing a name conflict.

The following example illustrates the
declaration of message destination references in the deployment
descriptor.

=== ...

<message-destination-ref>

 <description>

 This is a reference to a JMS queue used in the

 processing of Stock info

 </description>

 <message-destination-ref-name>

 jms/StockInfo

 </message-destination-ref-name>

 <message-destination-type>

 javax.jms.Queue

 </message-destination-type>

 _<message-destination-usage>_

 _Produces_

 _</message-destination-usage>_

</message-destination-ref>

===  ...

=== Application Assembler’s Responsibilities

By means of linking message consumers and
producers to one or more common logical destinations specified in the
enterprise bean deployment descriptor, the Application Assembler can
specify the flow of messages within an application. The Application
Assembler uses the _message-destination_ element, the
_message-destination-link_ element of the _message-destination-ref_
element, and the _message-destination-link_ element of an ejb-jar’s
_message-driven_ element to link message destination references to a
common logical destination.

The Application Assembler specifies the link
between message consumers and producers as follows:

* The Application Assembler uses the
_message-destination_ element to specify a logical message destination
within the application. The _message-destination_ element defines a
_message-destination-name_ , which is used for the purpose of linking.
* The Application Assembler uses the
_message-destination-link_ element of the _message-destination-ref_
element of an application component that produces messages to link it to
the target destination. The value of the _message-destination-link_
element is the name of the target destination, as defined in the
_message-destination-name_ element of the _message-destination_ element.
The _message-destination_ element can be in any module in the same Jakarta
EE application as the referencing component. The Application Assembler
uses the _message-destination-usage_ element of the
_message-destination-ref_ element to indicate that the referencing
application component produces messages to the referenced destination.
* If the consumer of messages from the common
destination is a message-driven bean, the Application Assembler uses the
_message-destination-link_ element of the _message-driven_ element to
reference the logical destination. If the Application Assembler links a
message-driven bean to its source destination, he or she should use the
_message-destination-type_ element of the _message-driven_ element to
specify the expected destination type. Otherwise, the Application
Assembler uses the _message-destination-link_ element of the
_message-destination-ref_ element of the application component that
consumes messages to link to the common destination. In the latter case,
the Application Assembler uses the _message-destination-usage_ element
of the _message-destination-ref_ element to indicate that the
application component consumes messages from the referenced destination.
* To avoid the need to rename message
destinations to have unique names within an entire Jakarta EE application,
the Application Assembler may use the following syntax in the
_message-destination-link_ element of the referencing application
component. The Application Assembler specifies the path name of the JAR
file containing the referenced message destination and appends the
_message-destination-name_ of the target destination separated from the
path name by #. The path name is relative to the referencing application
component JAR file. In this manner, multiple destinations with the same
_message-destination-name_ may be uniquely identified.
* When linking message destinations, the
Application Assembler must ensure that the consumers and producers for
the destination require a message destination of the same or compatible
type, as determined by the messaging system.

=== Deployer’s Responsibilities

The Deployer is responsible for the following:

* The Deployer must ensure that all the
declared message destination references are bound to administered
objects that exist in the operational environment. The Deployer may use,
for example, the JNDI _LinkRef_ mechanism to create a symbolic link to
the actual JNDI name of the target object. The Deployer may override the
linkage preferences of a message destination reference that includes a
_lookup-name_ element.
* The Deployer must ensure that the target
object is type-compatible with the type declared for the message
destination reference. This means that the target object must be of the
type indicated in the _message-destination-type_ element.
* The Deployer must observe the message
destination links specified by the Application Assembler.

=== Jakarta EE Product Provider’s Responsibilities

The Jakarta EE Product Provider must provide the
deployment tools that allow the Deployer to perform the tasks described
in the previous subsection. The deployment tools provided by the Jakarta EE
Product Provider must be able to process the information supplied in the
_message-destination-ref_ elements in the deployment descriptor.

At the minimum, the tools must be able to
inform the Deployer of any unresolved message destination references,
and allow him or her to resolve a message destination reference by
binding it to a specified compatible target object in the environment.

=== UserTransaction [[a1334]]References

Certain Jakarta EE application component types are
allowed to use the JTA _UserTransaction_ interface to start, commit, and
abort transactions. Such application components can find an appropriate
object implementing the _UserTransaction_ interface by looking up the
JNDI name _java:comp/UserTransaction_ or by requesting injection of a
_UserTransaction_ object using the _Resource_ annotation. The
_authenticationType_ and _shareable_ elements of the _Resource_
annotation must not be specified. The container is only required to
provide the _java:comp/UserTransaction_ name, or inject a
_UserTransaction_ object, for those components that can validly make use
of it. Any such reference to a _UserTransaction_ object is only valid
within the component instance that performed the lookup. See the
individual component definitions for further information.

The following example illustrates how an
application component acquires and uses a _UserTransaction_ object via
injection.

=== @Resource UserTransaction tx;



public void updateData(...) \{

 ...

 // Start a transaction.

 tx.begin();

 ...

 // Perform transactional operations on data.

 ...

 // Commit the transaction.

 tx.commit();

 ...

=== }

The following example illustrates how an
application component acquires and uses a _UserTransaction_ object using
a JNDI lookup.

=== public void updateData(...) \{

 ...

 // Obtain the default initial JNDI context.

 Context initCtx = new InitialContext();



 // Look up the UserTransaction object.

 UserTransaction tx =
(UserTransaction)initCtx.lookup(

 "java:comp/UserTransaction");



 // Start a transaction.

 tx.begin();

 ...

 // Perform transactional operations on data.

 ...

 // Commit the transaction.

 tx.commit();

 ...

=== }

A _UserTransaction_ object reference may also
be declared in a deployment descriptor in the same way as a resource
environment reference. Such a deployment descriptor entry may be used to
specify injection of a _UserTransaction_ object.

The requirements in this section only apply to
Jakarta EE products that include support for JTA.

=== Application Component Provider’s Responsibilities

The Application Component Provider is
responsible for requesting injection of a _UserTransaction_ object using
a _Resource_ annotation, or using the defined name to look up the
_UserTransaction_ object.

Only some application component types are
required to be able to access a _UserTransaction_ object; see
_link:#a2159[See Jakarta EE
Technologies]_ in this specification and the EJB specification for
details.

=== Jakarta EE Product Provider’s Responsibilities

The Jakarta EE Product Provider is responsible for
providing an appropriate _UserTransaction_ object as required by this
specification.

=== [[a1376]]TransactionSynchronizationRegistry References

The JTA _TransactionSynchronizationRegistry_
interface may be used by system level components such as persistence
managers that may be packaged with EJB or web application components.
Such components can find an appropriate object implementing the
_TransactionSynchronizationRegistry_ interface by looking up the JNDI
name _java:comp/TransactionSynchronizationRegistry_ or by requesting
injection of a _TransactionSynchronizationRegistry_ object using the
_Resource_ annotation. The _authenticationType_ and _shareable_ elements
of the _Resource_ annotation must not be specified. The container is
only required to provide the
_java:comp/TransactionSynchronizationRegistry_ name, or inject a
_TransactionSynchronizationRegistry_ object, for those components that
can validly make use of it. Any such reference to a
_TransactionSynchronizationRegistry_ object is only valid within the
component instance that performed the lookup. See the individual
component definitions for further information.

A _TransactionSynchronizationRegistry_ object
reference may also be declared in a deployment descriptor in the same
way as a resource environment reference. Such a deployment descriptor
entry may be used to specify injection of a
_TransactionSynchronizationRegistry_ object.

The requirements in this section only apply to
Jakarta EE products that include support for JTA.

=== Application Component Provider’s Responsibilities

The Application Component Provider is
responsible for requesting injection of a
_TransactionSynchronizationRegistry_ object using a _Resource_
annotation, or using the defined name to look up the
_TransactionSynchronizationRegistry_ object.

Only some application component types are
required to be able to access a _TransactionSynchronizationRegistry_
object; see _link:#a2159[See Jakarta
EE Technologies]_ in this specification for details.

=== Jakarta EE Product Provider’s Responsibilities

The Jakarta EE Product Provider is responsible for
providing an appropriate _TransactionSynchronizationRegistry_ object as
required by this specification.

=== [[a1385]]ORB References

Some Jakarta EE applications will need to make use
of the CORBA ORB to perform certain operations. Such applications can
find an appropriate object implementing the _ORB_ interface by looking
up the JNDI name _java:comp/ORB_ or by requesting injection of an _ORB_
object. The container is required to provide the _java:comp/ORB_ name
for all components except applets. Any such reference to a _ORB_ object
is only valid within the component instance that performed the lookup.

The following example illustrates how an
application component acquires and uses an _ORB_ object via injection.

=== @Resource ORB orb;



public void method(...) \{

 ...

 // Get the POA to use when creating object
references.

 POA rootPOA =
(POA)orb.resolve_initial_references("RootPOA");

 ...

=== }

The following example illustrates how an
application component acquires and uses an _ORB_ object using a JNDI
lookup.

=== public void method(...) \{

 ...

 // Obtain the default initial JNDI context.

 Context initCtx = new InitialContext();



 // Look up the ORB object.

 ORB orb =
(ORB)initCtx.lookup("java:comp/ORB");



 // Get the POA to use when creating object
references.

 POA rootPOA =
(POA)orb.resolve_initial_references("RootPOA");

 ...

=== }

An _ORB_ object reference may also be declared
in a deployment descriptor in the same way as a resource manager
connection factory reference. Such a deployment descriptor entry may be
used to specify injection of an _ORB_ object.

The _ORB_ instance available under the JNDI
name _java:comp/ORB_ may always be a shared instance. By default, the
_ORB_ instance injected into a component or declared via a deployment
descriptor entry may also be a shared instance. However, the application
may set the _shareable_ element of the _Resource_ annotation to _false_
, or may set the _res-sharing-scope_ element in the deployment
descriptor to _Unshareable_ , to request a non-shared _ORB_ instance.

The requirements in this section only apply to
Jakarta EE products that include support for interoperability using CORBA.

=== Application Component Provider’s Responsibilities

The Application Component Provider is
responsible for requesting injection of the _ORB_ object using the
Resource annotation, or using the defined name to look up the _ORB_
object. If the _shareable_ element of the _Resource_ annotation is set
to _false_ , the ORB object injected will not be the shared instance
used by other components in the application but instead will be a
private ORB instance used only by this component.

=== Jakarta EE Product Provider’s Responsibilities

The Jakarta EE Product Provider is responsible for
providing an appropriate _ORB_ object as required by this specification.

=== [[a1416]]Persistence Unit References

This section describes the metadata annotations
and deployment descriptor elements that allow the application component
code to refer to the entity manager factory for a persistence unit using
a logical name called a _persistence unit reference_ . Persistence unit
references are special entries in the application component’s
environment. The Deployer binds the persistence unit references to
entity manager factories that are configured in accordance with the
_persistence.xml_ specification for the persistence unit, as described
in the Java Persistence specification.

The requirements in this section only apply to
Jakarta EE products that include support for the Java Persistence API.

=== Application Component Provider’s Responsibilities

This subsection describes the Application
Component Provider’s view of locating the entity manager factory for a
persistence unit and defines his or her responsibilities. The first
subsection describes annotations for injecting references to an entity
manager factory for a persistence unit; the second describes the API for
accessing an entity manager factory using a persistence unit reference;
and the third describes syntax for declaring persistence unit references
in a deployment descriptor.

=== Injection of Persistence Unit References

A field or a method of an application component
may be annotated with the _PersistenceUnit_ annotation. The _name_
element specifies the name under which the entity manager factory for
the referenced persistence unit may be located in the JNDI naming
context. The optional _unitName_ element specifies the name of the
persistence unit as declared in the _persistence.xml_ file that defines
the persistence unit.

The following code example illustrates how an
application component uses annotations to declare persistence unit
references.

=== @PersistenceUnit

=== EntityManagerFactory emf;

=== @PersistenceUnit(unitName="InventoryManagement")

=== EntityManagerFactory inventoryEMF;

=== Programming Interfaces for Persistence Unit References

The Application
Component Provider must use persistence unit references to obtain
references to entity manager factories as follows.

* Assign an entry in the application
component’s environment to the persistence unit reference. (See
subsection link:#a1454[See Declaration
of Persistence Unit References in Deployment Descriptor] for information
on how persistence unit references are declared in the deployment
descriptor.) It is recommended that the Application Component Provider
organize all persistence unit references in the
_java:comp/env/persistence_ subcontext of the component’s environment.
* Lookup the entity manager factory for the
persistence unit in the application component’s environment using JNDI.
* Invoke the appropriate method on the entity
manager factory to obtain an entity manager instance.

The following code sample illustrates obtaining
an entity manager factory.

=== @PersistenceUnit(name="persistence/InventoryAppDB")

@Stateless

public class InventoryManagerBean implements
InventoryManager \{

 EJBContext ejbContext;

 ...

 public void updateInventory(...) \{

 ...

 // obtain the initial JNDI context

 Context initCtx = new InitialContext();



 // perform JNDI lookup to obtain entity
manager factory

 EntityManagerFactory = (EntityManagerFactory)

 initCtx.lookup(

 "java:comp/env/persistence/InventoryAppDB");



 // use factory to obtain application-managed
entity manager

 EntityManager em = emf.createEntityManager();

 ...

 }

=== }

=== [[a1454]]Declaration of Persistence Unit References in Deployment Descriptor

Although a persistence unit reference is an
entry in the application component’s environment, the Application
Component Provider must not use an _env-entry_
 element to declare it.

Instead, if metadata annotations are not used,
the Application Component Provider must declare all the persistence unit
references in the deployment descriptor using the _persistence-unit-ref_
elements. This allows the Application Assembler or Deployer to discover
all the persistence unit references used by an application component.
Deployment descriptor entries may also be used to specify injection of a
persistence unit reference into an application component.

Each
_persistence-unit-ref_ element describes a single entity manager factory
reference for the persistence unit. The _persistence-unit-ref_ element
consists of the optional _description_ and _persistence-unit-name_
elements, and the mandatory _persistence-unit-ref-name_ element.

The _persistence-unit-ref-name_ element
contains the name of the environment entry used in the application
component’s code. The name of the environment entry is relative to the
_java:comp/env_ context (e.g., the name should be
_persistence/InventoryAppDB_ rather than
_java:comp/env/persistence/InventoryAppDB_ ). The
_persistence-unit-name_ element is the name of the persistence unit, as
specified in the _persistence.xml_ file for the persistence unit.

The following example is the declaration of a
persistence unit reference used by the _InventoryManager_ enterprise
bean illustrated in the previous subsection.

===  ...

 <persistence-unit-ref>

 <description>

 Persistence unit for the inventory management

 application.

 </description>

 <persistence-unit-ref-name>

 persistence/InventoryAppDB

 </persistence-unit-ref-name>

 <persistence-unit-name>

 InventoryManagement

 </persistence-unit-name>

 </persistence-unit-ref>

===  ...

=== [[a1475]] Application Assembler’s Responsibilities

The Application Assembler can use the
_persistence-unit-name_ element in the deployment descriptor to
disambiguate a reference to a persistence unit.The Application Assembler
(or Application Component Provider) may use the following syntax in the
_persistence-unit-name_ element of the referencing application component
to avoid the need to rename persistence units to have unique names
within a Jakarta EE application. The Application Assembler specifies the
path name of the root of the _persistence.xml_ file for the referenced
persistence unit and appends the name of the persistence unit separated
from the path name by _#_ . The path name is relative to the referencing
application component jar file. In this manner, multiple persistence
units with the same persistence unit name may be uniquely identified
when the Application Assembler cannot change persistence unit names.

For example,

===  ...

 <persistence-unit-ref>

 <description>

 Persistence unit for the inventory management

 application.

 </description>

 <persistence-unit-ref-name>

 persistence/InventoryAppDB

 </persistence-unit-ref-name>

 <persistence-unit-name>

 ../lib/inventory.jar#InventoryManagement

 </persistence-unit-name>

 </persistence-unit-ref>

===  ...

The Application Assembler uses the
_persistence-unit-name_ element to link the persistence unit name
_InventoryManagement_ declared in the _InventoryManagerBean_ to the
persistence unit named _InventoryManagement_ defined in _inventory.jar_
.

The following rules apply to how a deployment
descriptor entry may override a _PersistenceUnit_ annotation:

* The relevant deployment descriptor entry is
located based on the JNDI name used with the annotation (either
defaulted or provided explicitly).
* The _persistence-unit-name_ overrides the
_unitName_ element of the annotation. The Application Assembler or
Deployer should exercise caution in changing this value, if specified,
as doing so is likely to break the application.
* The injection target, if specified, must
name exactly the annotated field or property method.

=== Deployer’s Responsibility

The Deployer uses deployment tools to
bind a persistence unit reference to the
actual entity manager factory configured for the persistence unit in the
target operational environment.

The Deployer must perform the following tasks
for each persistence unit reference declared in the metadata annotations
or deployment descriptor:

* Bind the persistence unit reference to an
entity manager factory configured for the persistence unit that exists
in the operational environment. The Deployer may use, for example, the
JNDI _LinkRef_ mechanism to create a symbolic link to the actual JNDI
name of the entity manager factory.
* If the persistence unit name is specified,
the Deployer should bind the persistence unit reference to the entity
manager factory for the persistence unit specified as the target.
* Provide any additional configuration
information that the entity manager factory needs for managing the
persistence unit, as described in the Java Persistence specification.

=== Jakarta EE Product Provider’s Responsibility

The Jakarta EE Product Provider is responsible for
the following:

* Provide the
deployment tools that allow the Deployer to
perform the tasks described in the previous subsection.
* Provide the implementation of the entity
manager factory classes for the persistence units that are configured
with the container. The implementation of the entity manager factory
classes may be provided by the container directly or by the container in
conjunction with a third-party persistence provider, as described in the
Java Persistence specification.

=== System Administrator’s Responsibility

The System
Administrator is typically responsible for the following:

* Add, remove, and configure entity manager
factories in the server environment.

In some scenarios, these tasks can be performed
by the Deployer.

=== [[a1513]]Persistence Context References

This section describes the metadata annotations
and deployment descriptor elements that allow the application component
code to refer to a container-managed entity manager of a specified
persistence context type using a logical name called a _persistence
context reference_ . Persistence context references are special entries
in the application component’s environment. The Deployer binds the
persistence context references to container-managed entity managers for
persistence contexts of the specified type and configured in accordance
with their persistence unit, as described in the Java Persistence
specification.

The requirements in this section only apply to
Jakarta EE products that include support for the Java Persistence API.

=== Application Component Provider’s Responsibilities

This subsection describes the Application
Component Provider’s view of locating container-managed entity managers
and defines his or her responsibilities. The first subsection describes
annotations for injecting references to container-managed entity
managers; the second describes the API for accessing references to
container-managed entity managers; and the third describes syntax for
declaring these references in a deployment descriptor.

=== Injection of Persistence Context References

A field or a method of an application component
may be annotated with the _PersistenceContext_ annotation. The _name_
element specifies the name under which a container-managed entity
manager for the referenced persistence unit may be located in the JNDI
naming context. The optional _unitName_ element specifies the name of
the persistence unit as declared in the _persistence.xml_ file that
defines the persistence unit. The optional _type_ element specifies
whether a transaction-scoped or extended persistence context is to be
used. If the type is not specified, a transaction-scoped persistence
context will be used. References to container-managed entity managers
with extended persistence contexts can only be injected into stateful
session beans. The optional _synchronization_ element specifies whether
the persistence context is always automatically synchronized with the
current transaction or whether it must be explicitly joined to the
transaction. If the _synchronization_ element is not specified, the
persistence context will be automatically synchronized. The optional
_properties_ element specifies configuration properties to be passed to
the persistence provider when the entity manager is created.

The following code example illustrates how an
application component uses annotations to declare persistence context
references.

=== @PersistenceContext(type=EXTENDED)

=== EntityManager em;

=== Programming Interfaces for Persistence Context References

The Application
Component Provider may use a persistence context reference to obtain a
reference to a container-managed entity manager configured for a
persistence unit as follows:

* Assign an entry in the application
component’s environment to the persistence context reference. (See
subsection link:#a1545[See Declaration
of Persistence Context References in Deployment Descriptor] for
information on how persistence context references are declared in the
deployment descriptor.) It is recommended that the Application Component
Provider organize all persistence context references in the
_java:comp/env/persistence_ subcontext of the component’s environment.
* Lookup the container-managed entity manager
for the persistence unit in the application component’s environment
using the JNDI API.

The following code sample illustrates obtaining
an entity manager for a persistence context.

=== @PersistenceContext(name="persistence/InventoryAppMgr")

@Stateless

public class InventoryManagerBean implements
InventoryManager \{



 public void updateInventory(...) \{

 ...



 // obtain the initial JNDI context

 Context initCtx = new InitialContext();



 // JNDI lookup to obtain container-managed
entity manager

 EntityManager = (EntityManager)

 initCtx.lookup(

 "java:comp/env/persistence/InventoryAppMgr");

 ...

 }

=== }

=== [[a1545]]Declaration of Persistence Context References in Deployment Descriptor

Although a persistence context reference is an
entry in the application component’s environment, the Application
Component Provider must not use an _env-entry_
 element to declare it.

Instead, if metadata annotations are not used,
the Application Component Provider must declare all the persistence
context references in the deployment descriptor using the
_persistence-context-ref_ elements. This allows the Application
Assembler or Deployer to discover all the persistence context references
used by an application component. Deployment descriptor entries may also
be used to specify injection of a persistence context reference into a
bean.

Each
_persistence-context-ref_ element describes a single container-managed
entity manager reference. The _persistence-context-ref_ element consists
of the optional _description_ , _persistence-unit-name_ ,
_persistence-context-type_ , _persistence-context-synchronization_ , and
_persistence-property_ elements, and the mandatory
_persistence-context-ref-name_ element.

The _persistence-context-ref-name_ element
contains the name of the environment entry used in the application
component’s code. The name of the environment entry is relative to the
_java:comp/env_ context (e.g., the name should be
_persistence/InventoryAppMgr_ rather than
_java:comp/env/persistence/InventoryAppMgr_ ). The
_persistence-unit-name_ element is the name of the persistence unit, as
specified in the _persistence.xml_ file for the persistence unit. The
_persistence-context-type_ element specifies whether a
transaction-scoped or extended persistence context is to be used. Its
value is either _Transaction_ or _Extended_ . If the persistence context
type is not specified, a transaction-scoped persistence context will be
used. The optional _persistence-context-synchronization_ element
specifies whether the persistence context is automatically synchronized
with the current transaction. Its value is either _Synchronized_ or
_Unsynchronized_ . If the persistence context synchronization is not
specified, the persistence context will be automatically synchronized.
The optional _persistence-property_ elements specify configuration
properties that are passed to the persistence provider when the entity
manager is created.

The following example is the declaration of a
persistence context reference used by the _InventoryManager_ enterprise
bean illustrated in the previous subsection.

===  ...

 <persistence-context-ref>

 <description>

 Persistence context for the inventory
management

 application.

 </description>

 <persistence-context-ref-name>

 persistence/InventoryAppDB

 </persistence-context-ref-name>

 <persistence-unit-name>

 InventoryManagement

 </persistence-unit-name>

 </persistence-context-ref>

===  ...

===  Application Assembler’s Responsibilities

The Application Assembler can use the
_persistence-unit-name_ element in the deployment descriptor to specify
a reference to a persistence unit using the syntax described in
link:#a1475[See Application Assembler’s
Responsibilities].” In this manner, multiple persistence units with the
same persistence unit name may be uniquely identified when the
persistence unit names cannot be changed.

For example,

===  ...

 <persistence-context-ref>

 <description>

 Persistence context for the inventory
management

 application.

 </description>

 <persistence-context-ref-name>

 persistence/InventoryAppDB

 </persistence-context-ref-name>

 <persistence-unit-name>

 ../lib/inventory.jar#InventoryManagement

 </persistence-unit-name>

 </persistence-context-ref>

===  ...

The Application Assembler uses the
_persistence-unit-name_ element to link the persistence unit name
_InventoryManagement_ declared in the _InventoryManagerBean_ to the
persistence unit named _InventoryManagement_ defined in _inventory.jar_
.

The following rules apply to how a deployment
descriptor entry may override a _PersistenceContext_ annotation:

* The relevant deployment descriptor entry is
located based on the JNDI name used with the annotation (either
defaulted or provided explicitly).
* The _persistence-unit-name_ overrides the
_unitName_ element of the annotation. The Application Assembler or
Deployer should exercise caution in changing this value, if specified,
as doing so is likely to break the application.
* The _persistence-context-type_ , if
specified, overrides the _type_ element of the annotation. In general,
the Application Assembler or Deployer should never change the value of
this element, as doing so is likely to break the application.
* The _persistence-context-synchronization_ ,
if specified, overrides the _synchronization_ element of the annotation.
In general, the Application Assembler or Deployer should never change
the value of this element, as doing so is likely to break the
application.
* Any _persistence-property_ elements are
added to those specified by the _PersistenceContext_ annotation. If the
name of a specified property is the same as one specified by the
_PersistenceContext_ annotation, the value specified in the annotation
is overridden.
* The injection target, if specified, must
name exactly the annotated field or property method.

=== Deployer’s Responsibility

The Deployer uses deployment tools to
bind a persistence context reference to the
container-managed entity manager for the persistence context of the
specified type and configured for the persistence unit in the target
operational environment.

The Deployer must perform the following tasks
for each persistence context reference declared in the metadata
annotations or deployment descriptor:

* Bind the persistence context reference to a
container-managed entity manager for a persistence context of the
specified type and configured for the persistence unit as specified in
the _persistence.xml_ file for the persistence unit that exists in the
operational environment. The Deployer may use, for example, the JNDI
_LinkRef_ mechanism to create a symbolic link to the actual JNDI name of
the entity manager.
* If the persistence unit name is specified,
the Deployer should bind the persistence context reference to an entity
manager for the persistence unit specified as the target.
* Provide any additional configuration
information that the entity manager factory needs for creating such an
entity manager and for managing the persistence unit, as described in
the Java Persistence specification.

=== Jakarta EE Product Provider’s Responsibility

The Jakarta EE Product
Provider is responsible for the following:

* Provide the
deployment tools that allow the Deployer to
perform the tasks described in the previous subsection.
* Provide the implementation of the entity
manager classes for the persistence units that are configured with the
container. This implementation may be provided by the container
directory or by the container in conjunction with a third-party
persistence provider, as described in the Java Persistence
specification.

=== System Administrator’s Responsibility

The System
Administrator is typically responsible for the following:

* Add, remove, and configure entity manager
factories in the server environment.

In some scenarios, these tasks can be performed
by the Deployer.

=== [[a1607]]Application Name and Module Name References

A component may access the name of the current
application using the pre-defined JNDI name _java:app/AppName_ . A
component may access the name of the current module using the
pre-defined JNDI name _java:module/ModuleName_ . Both of these names are
represented by _String_ objects.

=== Application Component Provider’s Responsibilities

The Application Component Provider is
responsible for requesting injection of the application name or module
name using a _Resource_ annotation on a _String_ method or field, or
using the defined name to look up the application name or module name.

=== Jakarta EE Product Provider’s Responsibilities

The Jakarta EE Product Provider is responsible
for providing the correct application name and module name _String_
objects as required by this specification.

=== [[a1613]]Application Client Container Property

An application may determine whether it is
executing in a Jakarta EE application client container by using the
pre-defined JNDI name _java:comp/InAppClientContainer_ . This property
is represented by a _Boolean_ object. If the application is running in a
Jakarta EE application client container, the value of this property is
true. If the application is running in a Jakarta EE web or EJB container,
the value of this property is false.

=== Application Component Provider’s Responsibilities

The Application Component Provider is
responsible for requesting injection of the application client container
property using a _Resource_ annotation on a _Boolean_ or _boolean_
method or field, or using the defined name to look up the application
client container property.

=== Jakarta EE Product Provider’s Responsibilities

The Jakarta EE Product Provider is responsible
for providing the correct application client container property as
required by this specification.

=== [[a1619]]Validator and Validator Factory References

This section describes the metadata annotations
and deployment descriptor entries that allow an application to obtain
instances of the Bean Validation _Validator_ and _ValidatorFactory_
types.

Applications that need to use those interfaces
can find appropriate objects by looking up the name
_java:comp/Validator_ for _Validator_ and _java:comp/ValidatorFactory_
for _ValidatorFactory_ , or by requesting the injection of an object of
the appropriate type via the _Resource_ annotation. The
_authenticationType_ and _shareable_ elements of the _Resource_
annotation must not be specified.

=== @Resource ValidatorFactory validatorFactory;



@Resource Validator validator;



For Validator objects, the default validation
context is used. This means that all such Validators will be equivalent
to those obtained by first acquiring a ValidatorFactory and then
invoking the getValidator method on it with no arguments.

In other words, the following two code
snippets are equivalent:



// obtaining a Validator directly

Context initCtx = new InitialContext();

Validator validator =
(Validator)initCtx.lookup(

 "java:comp/Validator");



// obtaining a Validator from a
ValidatorFactory

Context initCtx = new InitialContext();

Validator validator =

 ((ValidatorFactory) initCtx.lookup(

 "java:comp/ValidatorFactory"))

 .getValidator();



A _Validator_ or _ValidatorFactory_ object
reference may also be declared in a deployment descriptor in the same
way as a resource environment reference.

In order to customize the returned
_ValidatorFactory_ , an EJB, web or application client module may
specify a Bean Validation XML deployment descriptor, as described in the
Bean Validation specification.

A validation deployment descriptor only
affects _ValidatorFactory_ instances in that module.

There is no per-application validation
deployment descriptor.

=== Application Component Provider’s Responsibilities

The Application Component Provider is
responsible for requesting injection of a _Validator_ or of a
_ValidatorFactory_ using a _Resource_ annotation, or using the defined
names to look up a _Validator_ or _ValidatorFactory_ instance.

The Application Component Provider may
customize the _ValidatorFactory_ and (indirectly) _Validator_ instances
by including a Bean Validation deployment descriptor inside a specific
module of the application.

=== Jakarta EE Product Provider’s Responsibilities

The Jakarta EE Product Provider must make a
default _ValidatorFactory_ available at _java:comp/ValidatorFactory_ .
The default _ValidatorFactory_ available at _java:comp/ValidatorFactory_
must support use of CDI if CDI is enabled for the module. In particular,
all of the classes specified by the
_javax.validation.BootstrapConfiguration_ interface must be created as
non-contextual objects using CDI, as described in
link:#a2112[See Support for Dependency
Injection]”. These objects must be used to configure the default
_ValidatorFactory_ available at _java:comp/ValidatorFactory_ in
accordance with the bootstrapping APIs described by the Bean Validation
specification.

The default _ValidatorFactory_ is a single
instance per module; each lookup of _java:comp/ValidatorFactory_ returns
the same instance.

The default _Validator_ is created by the
default _ValidatoryFactory_ using the _getValidator_ method. Each lookup
of _java:comp/Validator_ returns a new _Validator_ instance.

=== [[a1652]]Resource Definition and Configuration

In addition to referencing resources as
defined in this chapter, an application may specify the definition and
configuration of resources that it requires in its operational
environment.

Each application has a set of “physical”
resources and services that it depends on (database storage, queueing,
mail, etc.) and which need to be made available to it when it is
deployed. Such resources may be scoped to the application instance or
may be shareable. An application may define a dependency upon such
resources in its environment by means of resource definition metadata.

The specification of resource definition
metadata provides information that can be used at the application’s
deployment to provision and configure the required resource. Further,
resource definitions allow an application to be deployed into a Jakarta EE
environment with more minimal administrative configuration.

Resources may be defined in any of the JNDI
namespaces described in link:#a616[See
Application Component Environment Namespaces]”. For example, a resource
may be defined:

=== in the _java:comp_ namespace, for use by a single component;

* in the _java:module_ namespace, for use by
all components in a module;
* in the _java:app_ namespace, for use by all
components in an application;
* in the _java:global_ namespace, for use by
all applications.

The following annotations (and corresponding
XML deployment descriptor elements) define resources:
_DataSourceDefinition_ , _JMSConnectionFactoryDefinition_ ,
_JMSDestinationDefinition_ , _MailSessionDefinition_ ,
_ConnectionFactoryDefinition_ , and _AdministeredObjectDefinition_ .

Once defined, a resource may be referenced by
a component using the _lookup_ element of the _Resource_ annotation or
the _lookup-name_ element of the _resource-ref_ deployment descriptor
element in order to bind the logical reference to the resource as
referenced in the application code to the resource defined in the
environment. __

The specificity of the resource definition
elements as provided by the Application Component Provider may vary
according to the needs of the application. For example:

* An application may require an instance of a
resource, but its needs may be general in that while it requires a
resource with certain properties, it does not require a particular
instance of the resource. It may expect the resource to be provisioned
and configured for it by the Deployer or System Administrator.
* An application may require a particular
instance of a resource (with specific configuration properties) that
already exists. For example, the resource may previously have been
created and configured by the Deployer or System Administrator.

The values specified for required annotation
elements (and corresponding XML deployment descriptor elements) must be
observed when the application is deployed. Changing a value that has
been specified for some optional elements (e.g., _transactional_ ) may
cause the application to work incorrectly. Changing a value that has
been specified for an optional element related to quality of service
(e.g., pool size, idle time, etc.) may affect the performance of the
application.

The following default values used in the
_DataSourceDefinition_ , _JMSConnectionFactoryDefinition_ ,
_JMSDestinationDefinition_ , _MailSessionDefinition_ , and
_ConnectionFactoryDefinition_ annotations indicate that an element value
is optional and has not been set:

=== integer-valued elements: _-1_

* string-valued elements: _“”_
* array-valued elements: _\{}_

=== Guidelines

The following guidelines should be observed
with regard to the specification of values for resource definition
elements.

* In general, the Application Component
Provider or Assembler should specify values for elements which, if
changed, would cause the application to break—for example, JNDI name,
isolation level. If multiple resource definitions are specified for a
given resource, they must be consistent.
* The Jakarta EE Product Provider may choose
suitable server-specific default values for optional elements for which
values have not been specified.

=== [[a1676]]Requirements Common to All Resource Definition Types

The following requirements apply to the
resource definitions described in Sections
link:#a1688[See DataSource Resource
Definition] through link:#a1967[See
Connector Administered Object Definition].

When an Application Component Provider or
Application Assembler specifies connectivity information to a “physical”
resource through a resource definition annotation or deployment
descriptor element, it is assumed that the physical resource exists. The
automatic provisioning of resources may be supported by an
implementation of this specification, but support for this functionality
is not required. If automatic provisioning of resources is not
supported, it is the Deployer’s responsibility (possibly in conjunction
with the System Administrator) to insure that the physical resource is
provisioned for use by the application.

=== JNDI Name

The Deployer and Jakarta EE Product Provider
must not alter the specified JNDI name. The requested resource must be
made available in JNDI under the specified name.

=== Resource Address

If the Application Component Provider or
Application Assembler has specified an address for a resource (server
name, port, etc.), a resource at the specified location should already
exist. If it does not, and if the automatic provisioning of resources is
not supported, it is the Deployer’s responsibility (possibly in
conjunction with the System Administrator) to insure that the resource
is provisioned for use by the applicationlink:#a3660[13].

If the resource has not been otherwise
provisioned and if automatic provisioning of resources is supported, the
Jakarta EE Product Provider is responsible for provisioning the resource.
If the requested resource cannot be made available or created, the
application must fail to deploy.

=== Quality of Service Elements

Quality of service elements may be altered by
the Deployer. The Jakarta EE Product Provider is permitted to impose
restrictions upon quality of service elements in accordance with its
implementation limits and quality of service guarantees. If quality of
service values that have been specified do not meet these restrictions,
the Product Provider must not reject the deployment (but must instead
use appropriate values).

=== Properties

All resource definition annotations and XML
elements support the use of property elements (elements named “
_properties_ ” or “ _property_ ”). A Jakarta EE Product Provider is
permitted to reject a deployment if a property that it recognizes has a
value that it does not support. A Jakarta EE Product Provider must not
reject a deployment on the basis of a property that it does not
recognize.

=== [[a1688]]DataSource Resource Definition

An application may define a _DataSource_
resource. A _DataSource_ resource is used to access a database using a
JDBC driver.

The _DataSource_ resource may be defined in
any of the JNDI namespaces described in
link:#a616[See Application Component
Environment Namespaces]”.

A _DataSource_ resource may be defined in a
web module, EJB module, application client module, or application
deployment descriptor using the _data-source_ element.

For example:



<data-source>

 <description>Sample DataSource
definition</description>

 <name> _java:app/MyDataSource_ </name>

 <class-name> _com.example.MyDataSource_
</class-name>

 <server-name>myserver.com</server-name>

 <port-number>6689</port-number>

 <database-name>myDatabase</database-name>

 <user>lance</user>

 <password>secret</password>

 <property>

 <name>Property1</name>

 <value>10</value>

 </property>

 <property>

 <name>Property2</name>

 <value>20</value>

 </property>

 <login-timeout>0</login-timeout>

 <transactional>false</transactional>


<isolation-level>TRANSACTION_READ_COMMITTED</isolation-level>

 <initial-pool-size>0</initial-pool-size>

 <max-pool-size>30</max-pool-size>

 <min-pool-size>20</min-pool-size>

 <max-idle-time>0</max-idle-time>

 <max-statements>50</max-statements>

</data-source>



A _DataSource_ resource may also be defined
using the _DataSourceDefinition_ annotation on a container-managed
class, such as a servlet or enterprise bean class.

For example:



 _@DataSourceDefinition(_

 _name="java:app/MyDataSource",_

 _className="com.example.MyDataSource",_

 _portNumber=6689,_

 _serverName="myserver.com",_

 _user="lance",_

 _password="secret")_



(Of course, we do not recommend including
passwords to production systems in the code, but it's often useful while
testing. Passwords, or other parts of the _DataSource_ definition, can
be overridden by a deployment descriptor when the application is
deployed.)

Once defined, a _DataSource_ resource may be
referenced by a component using the _resource-ref_ deployment descriptor
element or the _Resource_ annotation. For example, the above
_DataSource_ could be referenced as follows:



 _@Stateless_

 _public class MySessionBean \{_

 _@Resource(lookup = "java:app/MyDataSource")_

 _DataSource myDB;_

 _..._

 _}_



The following _DataSourceDefinition_
annotation elements (and corresponding XML deployment descriptor
elements) are considered to specify an address for a _DataSource_
resource: _serverName_ , _portNumber_ , _databaseName_ , _url_ .

The following _DataSourceDefinition_
annotation elements (and corresponding XML deployment descriptor
elements) are considered to be quality of service elements:
_loginTimeout_ , _initialPoolSize_ , _maxPoolSize_ , _minPoolSize_ ,
_maxIdleTime_ , _maxStatements_ .

=== Application Component Provider’s Responsibilities

The Application Component Provider is
responsible for the definition of a _DataSource_ resource using a
_DataSourceDefinition_ annotation or the _data-source_ deployment
descriptor element.

If the database has been previously
provisioned for the application (e.g., by administrative action), it is
the responsibility of the Application Component Provider to specify the
class name of the data source implementation class and the server and
port at which the database is to be accessed.

A URL should not be specified in conjunction
with address elements such as server name and port. If it is, the
precedence order is undefined and implementation specific.

=== Deployer’s Responsibilities

Requirements common to all resource
definition types are described in
link:#a1676[See Requirements Common to
All Resource Definition Types]”. The following additional requirements
apply:

=== If specified, user name and password should be used as specified.

* The transactional specification and
isolation level must be used as specified.

=== Jakarta EE Product Provider’s Responsibilities

Requirements common to all resource definition
types are described in link:#a1676[See
Requirements Common to All Resource Definition Types]”. The following
additional requirements apply:

* If a class name is specified, a resource
with the specified implementation class (or a subclass) must be
provided. If the class name is specified as _XADataSource_ , an XA
datasource must be provided.
* If an isolation level is specified, the
Product Provider must satisfy the request or provide a higher level of
isolation. If the request cannot be satisfied, the Product Provider must
reject the deployment.

=== [[a1756]]JMS Connection Factory Resource Definition

An application may define a JMS
_ConnectionFactory_ resource.

The JMS _ConnectionFactory_ resource may be
defined in any of the JNDI namespaces described in
link:#a616[See Application Component
Environment Namespaces]”.

A JMS _ConnectionFactory_ resource may be
defined in a web module, EJB module, application client module, or
application deployment descriptor using the jms-connection-factory
element.

For example:



<jms-connection-factory>

 <description>

 Sample JMS ConnectionFactory definition

 </description>

 <name> _java:app/MyJMSCF_ </name>

 <interface-name>

 _javax.jms.QueueConnectionFactory_

 </interface-name>

 <resource-adapter>myJMSRA</resource-adapter>

 <user>scott</user>

 <password>secret</password>

 <client-id>MyId</client-id>

 <property>

 <name>Property1</name>

 <value>10</value>

 </property>

 <property>

 <name>Property2</name>

 <value>20</value>

 </property>

 <transactional>false</transactional>

 <max-pool-size>30</max-pool-size>

 <min-pool-size>20</min-pool-size>

</jms-connection-factory>



A JMS _ConnectionFactory_ resource may also
be defined using the _JMSConnectionFactoryDefinition_ annotation on a
container-managed class, such as a servlet or enterprise bean class.

For example:



 _@JMSConnectionFactoryDefinition(_

 _name="java:app/MyJMSCF",_


_interfaceName="javax.jms.QueueConnectionFactory",_

 _resourceAdapter="myJMSRA")_



(As with the _DataSource_ definition, we do
not recommend including passwords to production systems in the code, but
it's often useful while testing. Passwords, or other parts of the
_JMSConnectionFactoryDefinition_ annotation, can be overridden by a
deployment descriptor when the application is deployed.)

Once defined, a JMS _ConnectionFactory_
resource may be referenced by a component using the _resource-ref_
deployment descriptor element or the _Resource_ annotation. For example,
the above JMS _ConnectionFactory_ could be referenced as follows:



 _@Stateless_

 _public class MySessionBean \{_

 _@Resource(lookup = "java:app/MyJMSCF")_

 _ConnectionFactory myCF;_

 _..._

 _}_



The following
_JMSConnectionFactoryDefinition_ annotation elements (and corresponding
XML deployment descriptor elements) are considered to specify an address
for a JMS _ConnectionFactory_ resource: _resourceAdapter_ .

The following
_JMSConnectionFactoryDefinition_ annotation elements (and corresponding
XML deployment descriptor elements) are considered to be quality of
service elements: _maxPoolSize_ , _minPoolSize_ .

=== Application Component Provider’s Responsibilities

The Application Component Provider is
responsible for the definition of a JMS _ConnectionFactory_ using a
_JMSConnectionFactoryDefinition_ annotation or the
_jms-connection-factory_ deployment descriptor element.

=== Deployer’s Responsibilities

Requirements common to all resource
definition types are described in
link:#a1676[See Requirements Common to
All Resource Definition Types]”. The following additional requirements
apply:

=== A resource of the specified interface type (or of the default interface type, if not specified) must be provided.

* If specified, user name and password should
be used as specified.
* The transactional specification must be
used as specified.
* If specified, the client id should be used
as specified.

=== Jakarta EE Product Provider’s Responsibilities

Requirements common to all resource
definition types are described in
link:#a1676[See Requirements Common to
All Resource Definition Types]”.

=== [[a1817]]JMS Destination Definition

An application may define a JMS _Destination_
resource. A JMS _Destination_ resource is a JMS Queue or Topic.

The JMS _Destination_ resource may be defined
in any of the JNDI namespaces described in
link:#a616[See Application Component
Environment Namespaces]”.

A JMS _Destination_ resource may be defined
in a web module, EJB module, application client module, or application
deployment descriptor using the _jms-destination_ element.

For example:

=== <jms-destination>

 <description>Sample JMS Destination
definition</description>

 <name> _java:app/MyJMSDestination_ </name>

 <interface-name> _javax.jms.Queue_
</interface-name>

 <resource-adapter>myJMSRA</resource-adapter>


<destination-name>myQueue1</destination-name>

 <property>

 <name>Property1</name>

 <value>10</value>

 </property>

 <property>

 <name>Property2</name>

 <value>20</value>

 </property>

</jms-destination>



A JMS _Destination_ resource may also be
defined using the _JMSDestinationDefinition_ annotation on a
container-managed class, such as a servlet or enterprise bean class.

For example:

===  _@JMSDestinationDefinition(_

 _name="java:app/MyJMSQueue",_

 _interfaceName="javax.jms.Queue",_

 _destinationName="myQueue1")_



The _JMSDestinationDefinition_ annotation can
be overridden by a deployment descriptor when the application is
deployed.

Once defined, a JMS _Destination_ resource
may be referenced by a component using either the _resource-env-ref_ or
_message-destination-ref_ deployment descriptor element or the
_Resource_ annotation. For example, the above _Destination_ could be
referenced as follows:



 _@Stateless_

 _public class MySessionBean \{_

 _@Resource(lookup = "java:app/MyJMSQueue")_

 _Queue myQueue;_

 _..._

 _}_



The following _JMSDestinationDefinition_
annotation elements (and corresponding XML deployment descriptor
elements) are considered to specify an address for a JMS _Destination_
resource: _resourceAdapter_ , _destinationName_ .

=== Application Component Provider’s Responsibilities

The Application Component Provider is
responsible for the definition of a JMS _Destination_ using a
_JMSDestinationDefinition_ annotation or the _jms-destination_
deployment descriptor element.

=== Deployer’s Responsibilities

Requirements common to all resource
definition types are described in
link:#a1676[See Requirements Common to
All Resource Definition Types]”. The following additional requirements
apply:

=== A resource of the specified interface type must be provided.

=== Jakarta EE Product Provider’s Responsibilities

Requirements common to all resource
definition types are described in
link:#a1676[See Requirements Common to
All Resource Definition Types]”.

=== [[a1863]]Mail Session Definition

An application may define a Mail _Session_
resource.

The Mail _Session_ resource may be defined in
any of the JNDI namespaces described in
link:#a616[See Application Component
Environment Namespaces]”.

A Mail _Session_ resource may be defined in a
web module, EJB module, application client module, or application
deployment descriptor using the _mail-session_ element.

For example:



<mail-session>

 <description>Sample Mail Session
definition</description>

 <name> _java:app/mail/MySession_ </name>

 <store-protocol> _imap_ </store-protocol>


<transport-protocol>smtp</transport-protocol>

 <host>somewhere.myco.com</host>

 <user>linda</user>

 <password>secret</password>

 <from>some.body@myco.com</from>

 <property>

 <name>mail.smtp.starttls.enable</name>

 <value>true</value>

 </property>

 <property>

 <name>mail.imap.connectiontimeout</name>

 <value>500</value>

 </property>

</mail-session>



A Mail _Session_ resource may also be defined
using the _MailSessionDefinition_ annotation on a container-managed
class, such as a servlet or enterprise bean class.

For example:



 _@MailSessionDefinition(_

 _name="java:app/mail/MySession",_

 _host="somewhere.myco.com",_

 _from="some.body@myco.com")_



The _MailSessionDefinition_ annotation can be
overridden by a deployment descriptor when the application is deployed.

Once defined, a Mail _Session_ resource may
be referenced by a component using the _resource-ref_ deployment
descriptor element or the _Resource_ annotation. For example, the above
_Destination_ could be referenced as follows:



 _@Stateless_

 _public class MySessionBean \{_

 _@Resource(lookup =
"java:app/mail/MySession")_

 _Session myMailSession;_

 _..._

 _}_



The following _MailSessionDefinition_
annotation elements (and corresponding XML deployment descriptor
elements) are considered to specify an address for a Mail _Session_
resource: _host_ .

=== Application Component Provider’s Responsibilities

The Application Component Provider is
responsible for the definition of a Mail Session using a
_MailSessionDefinition_ annotation or the _mail-session_ deployment
descriptor element.

If a mail server resource has been previously
provisioned for the application (e.g., by administrative action), it is
the responsibility of the Application Component Provider to specify the
mail server host name.

=== Deployer’s Responsibilities

Requirements common to all resource
definition types are described in
link:#a1676[See Requirements Common to
All Resource Definition Types]”. The following additional requirements
apply:

* If store protocol, store protocol class,
transport protocol, or transport protocol class has been specified, a
resource with the specified property or properties should be provided.
* If specified, the user name and password
should be used as specified.
* If specified, the from address should be
used as specified.

=== Jakarta EE Product Provider’s Responsibilities

Requirements common to all resource
definition types are described in
link:#a1676[See Requirements Common to
All Resource Definition Types]”.

=== [[a1917]]Connector Connection Factory Definition

An application may define Connector
connection factory resources.

The resource may be defined in any of the
JNDI namespaces described in
link:#a616[See Application Component
Environment Namespaces]”.

A Connector connection factory resource may
be defined in a web module, EJB module, or application deployment
descriptor using the _connection-factory_ element.

For example:



< _connection-factory_ >

 <description>Sample Connector resource
definition</description>

 <name> _java:app/myConnectionFactory_
</name>

 <interface-name>

 com.eis.ConnectionFactory

 </interface-name>

 <resource-adapter>MyEISRA</resource-adapter>

 <max-pool-size>20</max-pool-size>

 <min-pool-size>10</min-pool-size>


<transaction-support>XATransaction</transaction-support>

 <property>

 <name>Property1</name>

 <value>prop1val</value>

 </property>

 <property>

 <name>Property2</name>

 <value>prop2val</value>

 </property>

</ _connection-factory_ >



A Connector connection factory resource may
also be defined using the _ConnectionFactoryDefinition_ annotation on a
container-managed class, such as a servlet or enterprise bean class.

For example:



 _@ConnectionFactoryDefinition(_

 _name="java:app/myConnectionFactory",_

 _interfaceName="com.eis.ConnectionFactory",_

 _resourceAdapter="MyESRA")_



The _ConnectionFactoryDefinition_ annotation
can be overridden by a deployment descriptor when the application is
deployed.

Once defined, a Connector connection factory
resource may be referenced by a component using the _resource-ref_
deployment descriptor element or the _Resource_ annotation. For example,
the above Connector connection factory resource could be referenced as
follows:



 _@Stateless_

 _public class MySessionBean \{_

 _@Resource(lookup =
"java:app/myConnectionFactory")_

 _ConnectionFactory myCF;_

 _..._

 _}_

=== Application Component Provider’s Responsibilities

The Application Component Provider is
responsible for the definition of a Connector connection factory
resource using a _ConnectionFactoryDefinition_ annotation or the
_connection-factory_ deployment descriptor element.

=== Deployer’s Responsibilities

Requirements common to all resource
definition types are described in
link:#a1676[See Requirements Common to
All Resource Definition Types]”. The following additional requirements
apply:

* A resource of the specified type must be
provided.

=== Jakarta EE Product Provider’s Responsibilities

Requirements common to all resource
definition types are described in
link:#a1676[See Requirements Common to
All Resource Definition Types]”.

=== [[a1967]]Connector Administered Object Definition

An application may define a Connector
administered object resource. The administered object resource may be
defined in any of the JNDI namespaces described in
link:#a616[See Application Component
Environment Namespaces]”.

An administered object resource may be
defined in a web module, EJB module, or application deployment
descriptor using the _administered-object_ element. Properties that are
specified are used in the configuration of the administered object, as
described in the Connector specification.

For example:

=== <administered-object>

 <description>Sample Admin Object
definition</description>

 <name> _java:app/MyAdminObject_ </name>

 <class-name> _com.extraServices.AdminObject_
</class-name>

 <resource-adapter>myESRA</resource-adapter>

 <property>

 <name>Property1</name>

 <value>10</value>

 </property>

 <property>

 <name>Property2</name>

 <value>20</value>

 </property>

</administered-object>



An administered object resource may also be
defined using the _AdministeredObjectDefinition_ annotation on a
container-managed class, such as a servlet or enterprise bean class.

For example:



@AdministeredObjectDefinition(

 name= _"_ java:app/myAdminObject _"_ ,

 className= _"_ com.extraServices.AdminObject
_",_

 resourceAdapter= _"_ myESRA _"_ )



The _AdministeredObjectDefinition_ annotation
can be overridden by a deployment descriptor when the application is
deployed.

Once defined, an administered object resource
may be referenced by a component using the _resource-env-ref_ deployment
descriptor element or the _Resource_ annotation. For example, the above
administered object resource could be referenced as follows:



 _@Stateless public class MySessionBean \{_

 _@Resource(lookup =
"java:app/myAdminObject")_

 _AdminObject myAdminObject;_

 _..._

 _}_

=== Application Component Provider’s Responsibilities

The Application Component Provider is
responsible for the definition of an administered object resource using
an _AdministeredObjectDefinition_ annotation or the
_administered-object_ deployment descriptor element.

=== Deployer’s Responsibilities

Requirements common to all resource
definition types are described in
link:#a1676[See Requirements Common to
All Resource Definition Types]”. The following additional requirements
apply:

If a class name is specified, an administered
object resource of the specified class (or a subclass) must be provided.

=== Jakarta EE Product Provider’s Responsibilities

Requirements common to all resource
definition types are described in
link:#a1676[See Requirements Common to
All Resource Definition Types].”

=== [[a2009]]Default Data Source

The Jakarta EE Platform requires that a Jakarta EE
Product Provider provide a database in the operational environment (see
link:#a82[See Database]”). The Jakarta
EE Product Provider must also provide a preconfigured, default data
source for use by the application in accessing this database.

The Jakarta EE Product Provider must make the
default data source accessible to the application under the JNDI name
_java:comp/DefaultDataSource_ .

The Application Component Provider or
Application Assembler may explicitly bind a DataSource resource
reference to the default data source using the _lookup_ element of the
_Resource_ annotation or the _lookup-name_ element of the _resource-ref_
deployment descriptor element. For example,



@Resource(lookup="java:comp/DefaultDataSource")

DataSource myDS;



In the absence of such a binding, or an
equivalent product-specific binding, the mapping of the reference will
default to the product's default data source.

For example, the following will map to a
preconfigured data source for the product's default database:



@Resource

DataSource myDS;

=== Jakarta EE Product Provider's Responsibilities

The Jakarta EE Product Provider must provide a
database in the operational environment. The Jakarta EE Product Provider
must also provide a preconfigured, default data source for use by the
application in accessing this database under the JNDI name
_java:comp/DefaultDataSource_ .

If a DataSource resource reference is not
mapped to a specific data source by the Application Component Provider,
Application Assembler, or Deployer, it must be mapped by the Jakarta EE
Product Provider to a preconfigured data source for the Jakarta EE Product
Provider's default database.

=== [[a2025]]Default JMS Connection Factory

The Jakarta EE Platform requires that a Jakarta EE
Product Provider provide a JMS provider in the operational environment
(see link:#a104[See Jakarta™ Message
Service (JMS)]”) . The Jakarta EE Product Provider must also provide a
preconfigured, JMS ConnectionFactory for use by the application in
accessing this JMS provider.

The Jakarta EE Product Provider must make the
default JMS connection factory accessible to the application under the
JNDI name _java:comp/DefaultJMSConnectionFactory_ .

The Application Component Provider or
Application Assembler may explicitly bind a JMS ConnectionFactory
resource reference to the default connection factory using the _lookup_
element of the _Resource_ annotation or the _lookup-name_ element of the
_resource-ref_ deployment descriptor element. For example,



@Resource(name="myJMSCF",


lookup="java:comp/DefaultJMSConnectionFactory")

ConnectionFactory myJMScf;



In the absence of such a binding, or an
equivalent product-specific binding, the mapping of the reference will
default to a JMS connection factory for the product's JMS provider.

For example, the following will map to a
preconfigured connection factory for the product's default JMS provider:



@Resource(name="myJMSCF")

ConnectionFactory myJMScf;

=== Jakarta EE Product Provider's Responsibilities

The Jakarta EE Product Provider must provide a
JMS provider in the operational environment. The Jakarta EE Product
Provider must also provide a preconfigured, default JMS connection
factory for use by the application in accessing this provider under the
JNDI name _java:comp/DefaultJMSConnectionFactory_ .

If a JMS ConnectionFactory resource reference
is not mapped to a specific JMS connection factory by the Application
Component Provider, Application Assembler, or Deployer, it must be
mapped by the Jakarta EE Product Provider to a preconfigured JMS connection
factory for the Jakarta EE Product Provider's default JMS provider.

=== [[a2042]]Default Concurrency Utilities Objects

The Jakarta EE Platform requires that a Jakarta EE
Product Provider provide a preconfigured default managed executor
service, a preconfigured default managed scheduled executor service, a
preconfigured default managed thread factory, and a preconfigured
default context service for use by the application.

The Jakarta EE Product Provider must make the
default Concurrency Utilities for Jakarta EE objects accessible to the
application under the following JNDI names:

===  _java:comp/ DefaultManagedExecutorService_ for the preconfigured managed executor service

*
_java:comp/DefaultManagedScheduledExecutorService_ for the preconfigured
managed scheduled executor service
* j _ava:comp/DefaultManagedThreadFactory_
for the preconfigured managed thread factory
*  _java:comp/DefaultContextService_ for the
preconfigured context service

The Application Component Provider or
Application Assembler may explicitly bind a resource reference to a
default Concurrency Utilities object using the _lookup_ element of the
_Resource_ annotation or the _lookup-name_ element of the _resource-ref_
deployment descriptor element. For example,



@Resource(name="myManagedExecutorService,


lookup="java:comp/DefaultManagedExecutorService")

ManagedExecutorService
myManagedExecutorService;



In the absence of such a binding, or an
equivalent product-specific binding, the mapping of the reference will
default to the product's default managed executor service.

For example, the following will map to a
preconfigured default managed executor service for the product:



@Resource(name="myManagedExecutorService")

ManagedExecutorService
myManagedExecutorService;

=== Jakarta EE Product Provider's Responsibilities

The Jakarta EE Product Provider must provide the
following:

=== a preconfigured, default managed executor service for use by the application in accessing this service under the JNDI name _java:comp/DefaultManagedExecutorService_ ;

* a preconfigured, default managed scheduled
executor service for use by the application in accessing this service
under the JNDI name _java:comp/DefaultManagedScheduledExecutorService_ ;
* a preconfigured, default managed thread
factory for use by the application in accessing this factory under the
JNDI name _java:comp/DefaultManagedThreadFactory_ ;
* a preconfigured, default context service
for use by the application in accessing this service under the JNDI name
_java:comp/DefaultContextService_ .

If a Concurrency Utilities object resource
environment reference is not mapped to a specific configured object by
the Application Component Provider, Application Assembler, or Deployer,
it must be mapped by the Jakarta EE Product Provider to a preconfigured
Concurrency Utilities object for the Jakarta EE Product Provider.

=== [[a2067]]Managed Bean References

This section describes the metadata
annotations and deployment descriptor entries that allow an application
to obtain instances of a Managed Bean.

An instance of a named Managed Bean can be
obtained by looking up its name in JNDI using the same naming scheme
used for EJB components:



java:app/<module-name>/<bean-name>



java:module/<bean-name>



The latter will only work within the module
the Managed Bean is declared in.

Each such lookup must return a new instance.

Alternatively, the _Resource_ annotation can
be used to request the injection of a Managed Bean given either its type
or its name. If a name is specified using the _lookup_ element then the
type of the resource can be any of the types that the Managed Bean class
implements, including any of its interfaces. If no name is specified,
the type must be the Managed Bean class itself. (Note that the _name_
element of the _Resource_ annotation serves an entirely different
purpose than the _lookup_ element, consistently with other uses of
_Resource_ in this specification.) The _authenticationType_ and
_shareable_ elements of the _Resource_ annotation must not be specified.

For example, given a _ShoppingCartBean_ bean
named _“cart”_ defined in the same module as the client code and
implementing the _ShoppingCart_ interface, a client may use any of the
following methods to obtain an instance of the bean class:



@Resource ShoppingCartBean cart;



@Resource(lookup= _"_ java:module/cart")
ShoppingCart cart;



ShoppingCart cart = (ShoppingCart)
context.lookup("java:module/cart");



References to managed beans can be declared in
the deployment descriptor using the _resource-ref_ element. The
_res-type_ element must contain a type that the managed bean implements.
The _lookup-name_ must be present and refer to a managed bean by name.
The _res-sharing-scope_ and _res-auth_ elements may be omitted; if
present, they must have the values _Shareable_ and _Container_
respectively, so as to match the default values of the corresponding
elements of the _Resource_ annotation.

The following example shows how to declare
references to the shopping cart bean of the previous example, this time
using descriptors. (To make the example somewhat more realistic, one
should add an _injection-target_ child element to _resource-ref_ .)



<resource-ref>

 <res-ref-name>bean/cart</ref-ref-name>

 <ref-type>com.acme.ShoppingCart</ref-type>

 <lookup-name>java:module/cart</lookup-name>

</resource-ref>



=== Application Component Provider’s Responsibilities

The Application Component Provider is
responsible for requesting injection of a Managed Bean or for looking it
up in JNDI using an appropriate name.

=== Jakarta EE Product Provider’s Responsibilities

The Jakarta EE Product Provider is responsible
for providing appropriate instances of the requested Managed Bean class
as required by this specification.

=== [[a2099]]Bean Manager References

This section describes the metadata
annotations and deployment descriptor entries that allow an application
to obtain instances of the CDI _BeanManager_ type.

Typically, only portable extensions using the
CDI SPI need to access a _BeanManager_ . Application code may
occasionally require access to that interface; in that case, the
application should either look up a _BeanManager_ instance in JNDI under
the name _java:comp/BeanManager_ , or request the injection of an object
of type _javax.enterprise.inject.spi.BeanManager_ via the _Resource_
annotation. If the latter, the _authenticationType_ and _shareable_
elements of the _Resource_ annotation must not be specified.

=== @Resource BeanManager manager;



Per the CDI specification, a bean can also
request the injection of a _BeanManager_ using the _Inject_ annotation.

=== @Inject BeanManager manager;



A _BeanManager_ object reference may also be
declared in a deployment descriptor in the same way as a resource
environment reference.

=== Application Component Provider’s Responsibilities

The Application Component Provider is
responsible for requesting injection of a _BeanManager_ instance using a
_Resource_ annotation, or using the defined name to look up an instance
in JNDI.

=== Jakarta EE Product Provider’s Responsibilities

The Jakarta EE Product Provider is responsible
for providing appropriate _BeanManager_ instances as required by this
specification.

=== [[a2112]]Support for Dependency Injection

In Jakarta EE, support for dependency injection
annotations as specified in the Dependency Injection for Java
specification is mediated by CDI. Containers must support injection
points annotated with the _javax.inject.Inject_ annotation only to the
extent dictated by CDI.

Per the CDI specification, dependency
injection is supported on managed beans. There are currently three ways
for a class to become a managed bean:

. Being an EJB session bean component.
. Being annotated with the _ManagedBean_
annotation.
. Satisfying the conditions described in the
CDI specification.

Classes that satisfy at least one of these
conditions will be eligible for full dependency injection support as
described in the CDI specification.

Component classes listed in
link:#a651[See Component classes
supporting injection] that satisfy the third condition above, but
neither the first nor the second condition, can also be used as CDI
managed beans if they are annotated with a CDI bean-defining annotation
or contained in a bean archive for which CDI is enabled. However, if
they are used as CDI managed beans (e.g., injected into other managed
classes), the instances that are managed by CDI may not be the instances
that are managed by the Jakarta EE container.

Therefore, to make injection support more
uniform across all Jakarta EE component types, Jakarta EE containers are
required to support field, method, and constructor injection using the
_javax.inject.Inject_ annotation into all component classes listed in
link:#a651[See Component classes
supporting injection] as having the “Standard” level of injection
support, as well as the use of interceptors for these classes. Such
injection must be performed in the same logical phase as resource
injection of fields and methods annotated with the _Resource_
annotation. In particular, dependency injection must precede the
invocation of any methods annotated with the _PostConstruct_ annotation.
In supporting such injection points, the container must behave as if it
carried out the following steps, involving the use of the CDI SPI. Note
that using these steps causes the container to create a non-contextual
instance, which is not managed by CDI but rather by the Jakarta EE
container.

. Obtain a _BeanManager_ instance.
. Create an _AnnotatedType_ instance for the
component into which injection is to occur.
. Create an _InjectionTarget_ instance for
the annotated type.
. Create a _CreationalContext_ , passing in
_null_ to the _BeanManager_ _createCreationalContext_ method.
. Instantiate the component by calling the
_InjectionTarget_ _produce_ method.
. Inject the component instance by calling
the _InjectionTarget_ _inject_ method on the instance.
. Invoke the _PostConstruct_ callback, if
any, by calling the _InjectionTarget_ _postConstruct_ method on the
instance.

When such a non-contextual instance is to be
destroyed, the container should behave as if it carried out the
following steps.

. Invoke the _PreDestroy_ callback, if any,
by calling the _InjectionTarget_ _preDestroy_ method on the instance.
. Invoke the _InjectionTarget_ _dispose_
method on the instance.
. Invoke the _CreationalContext_ _release_
method to destroy any dependent objects of the instance.

Containers may optimize the steps above,
e.g., by avoiding calls to the actual CDI SPI and relying on
container-specific interfaces instead, as long as the outcome is the
same.

=== CHAPTER __ [[a2133]]

Application Programming
Interface

This chapter describes API requirements
for the Jakarta™ Platform, Enterprise Edition (Jakarta EE). Jakarta EE requires
the provision of a number of APIs for use by Jakarta EE applications,
starting with the core Java APIs and including many additional Java
technologies.

=== [[a2136]]Required APIs

Jakarta EE application components execute in
runtime environments provided by the containers that are a part of the
Jakarta EE platform. The full Jakarta EE platform supports four types of
containers corresponding to Jakarta EE application component types:
application client containers; applet containers; web containers for
servlets, JSP pages, JSF applications, JAX-RS applications; and
enterprise bean containers. A Jakarta EE profile may support only a subset
of these component types, as defined by the individual Jakarta EE profile
specification.

The per-technology requirements in this
chapter apply to any Jakarta EE product that includes the technology. Note
that even though a Jakarta EE profile might not require support for a
particular technology, a Jakarta EE product based on that Jakarta EE profile
might nonetheless include support for the technology. In such a case,
the requirements for that technology described in this chapter would
apply.

=== Java Compatible APIs

The containers provide all application
components with at least the Java Platform, Standard Edition, v8 (Java
SE) APIs. Containers may provide newer versions of the Java SE platform,
provided they meet all the Jakarta EE platform requirements. The Java SE
platform includes the following enterprise technologies:

=== Java IDL

* JDBC
* RMI-IIOP
* JNDI
* JAXP
* StAX
* JAAS
* JMX
* JAX-WS
* JAXB
* JAF
* SAAJ

=== Common Annotations

In particular, the applet execution
environment must be Java SE 8 compatible. Since typical browsers don’t
yet provide such support, Jakarta EE products may make use of the Java
Plugin to provide the required applet execution environment. Use of the
Java Plugin is not required, but is one method of meeting the
requirement to provide a Java SE 8 compatible applet execution
environment. This specification adds no requirements to the applet
container beyond those specified by Java SE.

Some of the enterprise technologies that are
included in Java SE 8 are also available independently of the Java SE
platform, and this specification requires newer versions of some of
these technologies, as described in the following section.

The specifications for the Java SE APIs are
available at _http://docs.oracle.com/javase/8/docs/_ .

=== Required Java Technologies

The full Jakarta EE platform also provides a
number of Java technologies in each of the containers defined by this
specification. _link:#a2159[See
Jakarta EE Technologies]_ indicates the technologies with their required
versions, which containers include the technologies, and whether the
technology is required (REQ), proposed optional (POPT), or optional
(OPT). Each Jakarta EE profile specification will include a similar table
describing which technologies are required for the profile. Note that
some technologies are marked Optional, as described in the next section.

=== [[a2159]]Jakarta EE Technologies

Java Technology

App Client

Web

EJB

Status

EJB 3.2

{empty}Ylink:#a3661[14]

Y

Y

{empty}REQ, OPTlink:#a3662[15],
POPTlink:#a3663[16]

Servlet 4.0

N

Y

N

REQ

JSP 2.3

N

Y

N

REQ

EL 3.0

N

Y

N

REQ

JMS 2.0

Y

Y

Y

REQ

JTA 1.2

N

Y

Y

REQ

JavaMail 1.6

Y

Y

Y

REQ

Connector 1.7

N

Y

Y

REQ

Web Services 1.4

Y

Y

Y

REQ

JAX-RPC 1.1

Y

Y

Y

OPT

JAX-RS 2.1

N

Y

N

REQ

WebSocket 1.1

N

Y

N

REQ

JSON-P 1.1

Y

Y

Y

REQ

JSON-B 1.0

Y

Y

Y

REQ

Concurrency Utilities for Java EE 1.0

N

Y

Y

REQ

Batch 1.0

N

Y

Y

REQ

JAXR 1.0

Y

Y

Y

OPT

Jakarta EE Management 1.1

Y

Y

Y

REQ

{empty}Jakarta EE Deployment
1.2link:#a3664[17]

N

N

N

OPT

JACC 1.5

N

Y

Y

REQ

JASPIC 1.1

N

Y

Y

REQ

Jakarta EE Security API 1.0

N

Y

Y

REQ

JSP Debugging 1.0

N

Y

N

REQ

JSTL 1.2

N

Y

N

REQ

Web Services Metadata 2.1

Y

Y

Y

REQ

JSF 2.3

N

Y

N

REQ

Common Annotations 1.3

Y

Y

Y

REQ

Java Persistence 2.2

Y

Y

Y

REQ

Bean Validation 2.0

Y

Y

Y

REQ

Managed Beans 1.0

Y

Y

Y

REQ

Interceptors 1.2

Y

Y

Y

REQ

Contexts and Dependency Injection for Jakarta EE
2.0

Y

Y

Y

REQ

Dependency Injection for Java 1.0

Y

Y

Y

REQ

{empty}All classes and interfaces required by
the specifications for the APIs must be provided by the Jakarta EE
containers indicated above. In some cases, a Jakarta EE product is not
required to provide objects that implement interfaces intended to be
implemented by an application server, nevertheless, the definitions of
such interfaces must be included in the Jakarta EE platform. If an
implementation includes support for a technology marked as Optional,
that technology must be supported in the containers specified above. If
a product implementation does not support a technology marked as
Optional, it must not include the APIs for that
technology.link:#a3665[18]

=== [[a2331]]Pruned Java Technologies

As the Jakarta EE specification has evolved,
some of the technologies originally included in Jakarta EE are no longer as
relevant as they were when they were introduced to the platform. The
Jakarta EE expert group follows a process first defined by the Java SE
expert group ( _http://mreinhold.org/blog/removing-features_ ) to prune
technologies from the platform in a careful and orderly way that
minimizes the impact to developers using these technologies, while
allowing the platform to grow even stronger. In short, the process
defines two steps:



. The Umbrella Expert Group (UEG) for release
N of the platform decides to propose that a particular feature be
removed. The specification for that release documents the proposal.
. The UEG for release N+1 decides whether to
remove the feature from that release, retain it as a required component,
or leave it in the "proposed removal" state for the next UEG to decide.



The result of successfully applying this
policy to a feature is not the actual deletion of the feature but rather
the conversion of the feature from a required component of the platform
into an optional component. No actual removal from the specification
occurs, although the feature may be removed from products at the choice
of the product vendor.

Technologies that have been pruned as of Jakarta
EE 8 are marked Optional in
link:#a2159[See Jakarta EE
Technologies]. Technologies that may be pruned in a future release are
marked Proposed Optional in
link:#a2159[See Jakarta EE
Technologies].

=== [[a2339]]Java Platform, Standard Edition (Java SE) Requirements

=== Programming Restrictions

 _The_ Jakarta EE _programming model divides
responsibilities between Application Component Providers and_ Jakarta EE
_Product Providers: Application Component Providers focus on writing
business logic and the_ Jakarta EE _Product Providers focus on providing a
managed system infrastructure in which the application components can be
deployed._

 _This division leads to a restriction on the
functionality that application components can contain. If application
components contain the same functionality provided by Jakarta EE system
infrastructure, there are clashes and mis-management of the
functionality._

 _For example, if enterprise beans were
allowed to manage threads, the_ Jakarta EE _platform could not manage the
life cycle of the enterprise beans, and it could not properly manage
transactions._

Since we do not want to subset the Java SE
platform, and we want Jakarta EE Product Providers to be able to use Java
SE products without modification in the Jakarta EE platform, we use the
Java SE security permissions mechanism to express the programming
restrictions imposed on Application Component Providers.

In this section, we specify the Java SE
security permissions that the Jakarta EE Product Provider must provide for
each application component type. We call these permissions the Jakarta EE
security permissions set. The Jakarta EE security permissions set is a
required part of the Jakarta EE API contract. We also specify the set of
permissions that the Jakarta EE Product Provider must be able to restrict
from being provided to application components. In addition, we specify
the means by which application component providers may declare the need
for specific permissions and how these declarations must be processed by
Jakarta EE products.

The Java SE security permissions are fully
described in
_http://docs.oracle.com/javase/8/docs/technotes/guides/security/permissions.html_
.

=== Jakarta EE Security Manager Related Requirements

Every Jakarta EE product must be capable of
running with a Java security manager that enforces Java security
permissions and that prevents application components from performing
operations for which they have not been provided the required
permissions.

=== Jakarta EE Product Provider’s Responsibilities

A Jakarta EE product may allow application
components to run without a security manager, but every Jakarta EE product
must be capable of running application components with a security
manager that enforces security permissions, as described below.

The set of security permissions provided to
application components by a particular installation is a matter of
policy outside the scope of this specification, however, every Jakarta EE
product must be capable of running with a configuration that provides
application classes and packaged libraries the permissions defined in
link:#a2366[See Jakarta EE Security
Permissions Set].

All Jakarta EE products must allow the set of
permissions available to application classes in a module to be
configurable, providing application components in some modules with
different permissions than those described in
link:#a2366[See Jakarta EE Security
Permissions Set].

As defined in
link:#a2496[See Declaring Permissions
Required by Application Components],” a component provider may declare
the permissions required by the application classes and libraries
packaged in a module. When a component provider has declared the
permissions required by a module, on successful deployment of the
module, at least the declared permissions must have been granted to the
application classes and libraries packaged in the module. If security
permissions are declared that conflict with the policy of the product
installation, the Jakarta EE product must fail deployment of the
application module. If an application module does not contain a
declaration of required security permissions and deployment otherwise
succeeds, the Jakarta EE product must grant the application classes and
libraries the permissions established by the security policy of the
installation. The Jakarta EE product must ensure that the system
administrator for the installation be able to define the security policy
for the installation to include the permissions in
link:#a2366[See Jakarta EE Security
Permissions Set].

Note that, on some installations of Jakarta EE
products, the security policy of the installation may be such that
applications are granted fewer permissions than those defined in
link:#a2366[See Jakarta EE Security
Permissions Set] and, as a result, some applications that declare only
the permissions defined in
link:#a2366[See Jakarta EE Security
Permissions Set] may not be deployable. Other applications that require
the same permissions but do not declare them may deploy but will
encounter runtime failures when the missing permission is required by
the application component.

Every Jakarta EE product must be capable of
running with a Java security manager and with an installation policy
that does not grant the permissions described in
link:#a2438[See Restrictable Jakarta EE
Security Permissions] to Web, EJB, and resource adapter components. That
environment must otherwise fully support the requirements of this
specification.

=== Application Component Provider’s Responsibilities

To ensure that application deployment will
only succeed if required permissions are compatible with security policy
of the installation environment, application component providers should
declare all Java security permissions required by their application
components.

link:#a2496[See
Declaring Permissions Required by Application Components],” defines the
mechanism(s) by which required permissions may be declared.

Note that, while FilePermissions or
SocketPermissions for specific resources may be granted as a result of
application components declaring them as required, the local operating
system or network security policy may restrict access to the requested
resources. This may result in a runtime failure to access these
resources even though deployment of the application has succeeded.

=== System Administrator’s Responsibilities

Security policy requirements differ from one
installation environment to another. The system administrator is
responsible for configuring the permissions available to application
modules to meet the security policy requirements of the installation
environment. For example, cloud environments may require greater
restrictions on the system resources available to applications than
on-premise enterprise installations. Note that restricting the
permissions beyond those in
link:#a2366[See Jakarta EE Security
Permissions Set] may prevent some applications from working correctly.

Care should be taken by the system
administrator to ensure that resources that are expected to be available
to application components are appropriately represented in the security
policy of the operational environment.

In particular, the temporary file directory
made available through the ServletContext attribute
_javax.servlet.context.tempdir_ should be available to deployed
applications. The security policy of the operational environment should
grant the application server process access to the corresponding part of
the file system. The Jakarta EE Product must be capable of using the
security manager to enforce that an application only has access to the
part of the filesystem namespace named by the
_javax.security.context.tempdir_ attribute, and that that part of the
filesystem namespace is separate from the corresponding filesystem
namespace available to other applications.

=== Listing of the Jakarta EE Security Permissions Set

link:#a2366[See
Jakarta EE Security Permissions Set] lists the Java permissions that Jakarta
EE components (by type) can reliably be granted by a Jakarta EE product,
given appropriate local installation configuration.

=== [[a2366]]Jakarta EE Security Permissions Set

Security Permissions

Target

Action

Application Clients





 _java.awt.AWTPermission_

accessClipboard



 _java.awt.AWTPermission_

accessEventQueue



 _java.awt.AWTPermission_

showWindowWithout

WarningBanner



 _java.lang.RuntimePermission_

exitVM



 _java.lang.RuntimePermission_

loadLibrary.*



 _java.lang.RuntimePermission_

queuePrintJob



 _java.net.SocketPermission_

*

connect

 _java.net.SocketPermission_

localhost:1024-

accept,listen

 _java.io.FilePermission_

*

read,write

 _java.util.PropertyPermission_

*

read

Applet Clients





 _java.net.SocketPermission_

 _codebase_

connect

 _java.util.PropertyPermission_

 _limited_

read

Web, EJB, and Resource Adapter

Components





 _java.lang.RuntimePermission_

loadLibrary.*



 _java.lang.RuntimePermission_

queuePrintJob



 _java.net.SocketPermission_

*

connect

 _java.io.FilePermission_

*

{empty}read,write link:#a3666[19]

java.io.FilePermission

file:$\{javax.servlet.context.tempdir}

{empty}read, write link:#a3667[20]

 _java.util.PropertyPermission_

*

read

=== Restrictable Jakarta EE Security Permissions

link:#a2438[See
Restrictable Jakarta EE Security Permissions] lists the Java permissions
that a Jakarta EE product must be capable of restricting when running a Web
or EJB application component. If the Target field is empty, a Jakarta EE
product must be capable of deploying application modules such that no
instances of that permission are granted to the components in the
application module.



=== [[a2438]]Restrictable Jakarta EE Security Permissions

Security Permissions

Target

Action

Web, EJB, and Resource Adapter Components





java.security.AllPermission





java.security.SecurityPermission





java.security.UnresolvedPermission





java.awt.AWTPermission





java.io.SerializablePermission





java.lang.reflect.ReflectPermission





 _java.lang.RuntimePermission_

{empty}<any except loadLibrary.* and
queuePrintJob> link:#a3668[21]



 _java.net.NetPermission_





 _java.sql.SQLPermission_





 _java.util.PropertyPermission_

<any>

{empty}write link:#a3669[22]

java.util.logging.LoggingPermission





javax.net.ssl.SSLPermission





java.security.auth.AuthPermission





java.security.auth.PrivateCredentialPermission





java.security.auth.kerberos.DelegationPermission





java.security.auth.kerberos.ServicePermission





javax.sound.sampled.AudioPermission





=== [[a2496]]Declaring Permissions Required by Application Components

By declaring the permissions required by an
application as described in this section, an application component
provider is ensured, through the successful deployment of his or her
application, that the Jakarta EE Product has granted at least the declared
permissions to the classes and libraries packaged in the application
module.

Since the specific set of permissions granted
to a successfully deployed application is a function of the security
policy for the installation and the permissions declared within the
_permissions.xml_ files, the application component provider is ensured
that the effective permission set consists of at least those permissions
that are declared within the application.

Permission declarations must be stored in
_META-INF/permissions.xml_ file within an EJB, web, application client,
or resource adapter archive in order for them to be located and
subsequently processed by the deployment machinery of the Jakarta EE
Product. The Jakarta EE Product is not required to support
_permissions.xml_ files that specify permission classes that are
packaged in the application.

The permissions for a packaged library are
the same as the permissions for the module. Thus, if a library is
packaged in a _.war_ file, it gets the permissions of the _.war_ file.

For applications packaged in an _.ear_ file,
the declaration of permissions must be at _.ear_ file level. This
permission set is applied to all modules and libraries packaged within
the _.ear_ file or within its contained modules. Any _permissions.xml_
files within such packaged modules are ignored, regardless of whether a
_permissions.xml_ file has been supplied for the _.ear_ file itself.

The fact that these permission declarations
are being made from within the context of a particular application
implies the codeBase(s) to which the grant should be made. This
simplifies the syntax that is needed to just the Permission class name
and two String arguments. This aligns the declaration syntax with the
default policy language and the constructor signature for permissions
that is compliant with the default policy syntax.



permission <class> [<name> [, <action
list>]];



The following is an example of a permission
set declaration:

...

<permissions>

 <permission>


<class-name>java.io.FilePermission</class-name>

 <name>/tmp/abc</name>

 <actions>read,write</actions>

 </permission>

 <permission>


<class-name>java.lang.RuntimePermission</class-name>

 <name>createClassLoader</name>

 </permission>

</permissions>

...



The Jakarta EE permissions XML Schema is located
at _http://xmlns.jcp.org/xml/ns/javaee/permissions_8.xsd_ .

=== Additional Requirements

=== [[a2523]]Networking

The Java SE platform includes a pluggable
mechanism for supporting multiple URL protocols through the
_java.net.URLStreamHandler_ class and the
_java.net.URLStreamHandlerFactory_ interface.

The following URL protocols must be supported:

*  _file_ _:_ Only reading from a _file_ URL
need be supported. That is, the corresponding _URLConnection_ object’s
_getOutputStream_ method may fail with an _UnknownServiceException_ .
File access is restricted according to the permissions described above.
*  _http_ _:_ Version 1.1 of the HTTP protocol
must be supported. An _http_ URL must support both input and output.
*  _https_ : SSL version 3.0 and TLS version 1.2
must be supported by _https_ URL objects. Both input and output must be
supported.

The Java SE platform also includes a mechanism
for converting a URL’s byte stream to an appropriate object, using the
_java.net.ContentHandler_ class and _java.net.ContentHandlerFactory_
interface. A _ContentHandler_ object can convert a MIME byte stream to
an object. _ContentHandler_ objects are typically accessed indirectly
using the _getContent_ method of _URL_ and _URLConnection_ .

When accessing data of the following MIME types
using the _getContent_ method, objects of the corresponding Java type
listed in _link:#a2531[See Java Type of
Objects Returned When Using the getContent Method]_ must be returned.

=== Java Type of Objects Returned When Using[[a2531]] the getContent Method

MIME Type

Java Type

 _image/gif_

 _java.awt.Image_

 _image/jpeg_

 _java.awt.Image_

 _image/png_

 _java.awt.Image_

Many environments will use HTTP proxies rather
than connecting directly to HTTP servers. If HTTP proxies are being used
in the local environment, the HTTP support in the Java SE platform
should be configured to use the proxy appropriately. Application
components must not be required to configure proxy support in order to
use an _http_ URL.

Most enterprise environments will include a
firewall that limits access from the internal network (intranet) to the
public Internet, and vice versa. It is typical for access using the HTTP
protocol to pass through such firewalls, perhaps by using proxy servers.
It is not typical that general TCP/IP traffic, including RMI-JRMP, and
RMI-IIOP, can pass through firewalls.

These considerations have implications on the
use of various protocols to communicate between application components.
This specification requires that HTTP access through firewalls be
possible where local policy allows. Some Jakarta EE products may provide
support for tunneling other communication through firewalls, but this is
neither specified nor required. Application developers should consider
the impact of these issues in the design of applications, particularly
in view of cloud environments, where a cloud platform provider might
only allow HTTP-based access.

=== JDBC™ API

The JDBC API, which is part of the Java SE
platform, allows for access to a wide range of data storage systems. The
Java SE platform, however, does not require that a system meeting the
Java Compatible™ quality standards provide a database that is accessible
through the JDBC API.

To allow for the development of portable
applications, the Jakarta EE specification does require that such a
database be available and accessible from a Jakarta EE product through the
JDBC API. Such a database must be accessible from web components,
enterprise beans, and application clients, but need not be accessible
from applets. In addition, the driver for the database must meet the
JDBC Compatible requirements in the JDBC specification.

Jakarta EE applications should not attempt to
load JDBC drivers directly. Instead, they should use the technique
recommended in the JDBC specification and perform a JNDI lookup to
locate a _DataSource_ object. The JNDI name of the _DataSource_ object
should be chosen as described in
link:#a1120[See Resource Manager
Connection Factory References].” The Jakarta EE platform must be able to
supply a _DataSource_ that does not require the application to supply
any authentication information when obtaining a database connection. Of
course, applications may also supply a user name and password when
connecting to the database.

When a JDBC API connection is used in an
_enterprise bean_ , the transaction characteristics will typically be
controlled by the container. The component should not attempt to change
the transaction characteristics of the connection, commit the
transaction, roll back the transaction, or set autocommit mode. Attempts
to make changes that are incompatible with the current transaction
context may result in a _SQLException_ being thrown. The EJB
specification contains the precise rules for _enterprise beans._

Note that the same restrictions apply when a
component creates a transaction using the JTA _UserTransaction_
interface. The component should not attempt the operations listed above
on the JDBC _Connection_ object that would conflict with the transaction
context.

Drivers supporting the JDBC API in a Jakarta EE
environment must meet the JDBC API Compliance requirements as specified
in the JDBC specification.

The JDBC API includes APIs for connection
naming via JNDI, connection pooling, and distributed transaction
support. The connection pooling and distributed transaction features are
intended for use by JDBC drivers to coordinate with an application
server. Jakarta EE products are not required to support the application
server facilities described by these APIs, although they may prove
useful.

The Connector architecture defines an SPI
that essentially extends the functionality of the JDBC SPI with
additional security functionality, and a full packaging and deployment
functionality for resource adapters. A Jakarta EE product that supports the
Connector architecture must support deploying and using a JDBC driver
that has been written and packaged as a resource adapter using the
Connector architecture.

The JDBC 4.2 specification is available at
_https://jcp.org/en/jsr/detail?id=221_ .

=== [[a2553]]Jakarta™ API for XML Web Services (JAX-WS) Requirements

The JAX-WS specification provides support for
web services that use the JAXB API for binding XML data to Java objects.
The JAX-WS specification defines client APIs for accessing web services
as well as techniques for implementing web service endpoints. The Web
Services for Jakarta EE specification describes the deployment of
JAX-WS-based services and clients. The EJB and Servlet specifications
also describe aspects of such deployment. It must be possible to deploy
JAX-WS-based applications using any of these deployment models.

The JAX-WS specification describes the
support for message handlers that can process message requests and
responses. In general, these message handlers execute in the same
container and with the same privileges and execution context as the
JAX-WS client or endpoint component with which they are associated.
These message handlers have access to the same JNDI _java:comp/env_
namespace as their associated component. Custom serializers and
deserializers, if supported, are treated in the same way as message
handlers.

The JAX-WS specification is available at
_http://jcp.org/en/jsr/summary?id=224_ .

=== Java IDL (Proposed Optional)

The requirements in this section only apply
to Jakarta EE products that support interoperability using CORBA.

Java IDL allows applications to access any
CORBA object, written in any language, using the standard IIOP protocol.
The Jakarta EE security restrictions typically prevent all application
component types except application clients from creating and exporting a
CORBA object, but all Jakarta EE application component types can be clients
of CORBA objects.

A Jakarta EE product must support Java IDL as
defined by chapters 1 - 8, 13, and 15 of the CORBA 2.3.1 specification,
available at _http://www.omg.org/cgi-bin/doc?formal/99-10-07_ , and the
IDL To Java Language Mapping Specification, available at
_http://www.omg.org/cgi-bin/doc?ptc/2000-01-08_ .

The IIOP protocol supports the ability to
multiplex calls over a single connection. All Jakarta EE products must
support requests from clients that multiplex calls on a connection to
either Java IDL server objects or RMI-IIOP server objects (such as
enterprise beans). The server must allow replies to be sent in any
order, to avoid deadlocks where one call would be blocked waiting for
another call to complete. Jakarta EE clients are not required to multiplex
calls, although such support is highly recommended.

A Jakarta EE product must provide support for a
CORBA Portable Object Adapter (POA) to support portable stub, skeleton,
and tie classes. A Jakarta EE application that defines or uses CORBA
objects other than enterprise beans must include such portable stub,
skeleton, and tie classes in the application package.

Jakarta EE applications need to use an instance
of _org.omg.CORBA.ORB_ to perform many Java IDL and RMI-IIOP operations.
The default ORB returned by a call to _ORB.init(new String[0], null)_
must be usable for such purposes; an application need not be aware of
the implementation classes used for the ORB and RMI-IIOP support.

In addition, for performance reasons it is
often advantageous to share an ORB instance among components in an
application. To support such usage, all web, enterprise bean, and
application client containers are required to provide an ORB instance in
the JNDI namespace under the name _java:comp/ORB_ . The container is
allowed, but not required, to share this instance between components.
The container may also use this ORB instance itself. To support
isolation between applications, an ORB instance should not be shared
between components in different applications. To allow this ORB instance
to be safely shared between components, portable components must
restrict their usage of certain ORB APIs and functionality:

* Do not call the ORB _shutdown_ method.
* Do not call the _org.omg.CORBA_2_3.ORB_
methods _register_value_factory_ and _unregister_value_factory_ with an
_id_ used by the container.

A Jakarta EE product must provide a COSNaming
service to support the EJB interoperability requirements. It must be
possible to access this COSNaming service using the Java IDL COSNaming
APIs. Applications with appropriate privileges must be able to lookup
objects in the COSNaming service. COSNaming is defined in the
Interoperable Naming Service specification, available at
_http://www.omg.org/cgi-bin/doc?formal/2000-06-19_ .

=== RMI-JRMP

JRMP is the Java technology-specific Remote
Method Invocation (RMI) protocol. The Jakarta EE security restrictions
typically prevent all application component types except application
clients from creating and exporting an RMI object, but all Jakarta EE
application component types can be clients of RMI objects.

=== RMI-IIOP (Proposed Optional)

The requirements in this section only apply
to Jakarta EE products that include an EJB container and support
interoperability using RMI-IIOP.

RMI-IIOP allows objects defined using RMI
style interfaces to be accessed using the IIOP protocol. It must be
possible to make any remote _enterprise bean accessible via_ RMI-IIOP.
Some Jakarta EE products will simply make all remote enterprise beans
always (and only) accessible via RMI-IIOP; other products might control
this via an administrative or deployment action. These and other
approaches are allowed, provided that any remote enterprise bean (or by
extension, all remote enterprise beans) can be made accessible using
RMI-IIOP.

Components accessing remote _enterprise
beans_ may need to use the _narrow_ method of the
_javax.rmi.PortableRemoteObject_ class, under circumstances described in
the EJB specification. Because remote enterprise beans may be deployed
using other RMI protocols, portable applications must not depend on the
characteristics of RMI-IIOP objects (for example, the use of the _Stub_
and _Tie_ base classes) beyond what is specified in the EJB
specification.

The Jakarta EE security restrictions typically
prevent all application component types, except application clients,
from creating and exporting an RMI-IIOP object. All Jakarta EE application
component types can be clients of RMI-IIOP objects. Jakarta EE applications
should also use JNDI to lookup non-EJB RMI-IIOP objects. The JNDI names
used for such non-EJB RMI-IIOP objects should be configured at
deployment time using the standard environment entries mechanism (see
link:#a607[See JNDI Naming Context]”).
The application should fetch a name from JNDI using an environment
entry, and use the name to lookup the RMI-IIOP object. Typically such
names will be configured to be names in the COSNaming name service.

This specification does not provide a
portable way for applications to bind objects to names in a name
service. Some products may support use of JNDI and COSNaming for binding
objects, but this is not required. Portable Jakarta EE application clients
can create non-EJB RMI-IIOP server objects for use as callback objects,
or to pass in calls to other RMI-IIOP objects.

Note that while RMI-IIOP doesn’t specify how
to propagate the current security context or transaction context, the
EJB interoperability specification does define such context propagation.
This specification only requires that the propagation of context
information as defined in the EJB specification be supported in the use
of RMI-IIOP to access enterprise beans. The propagation of context
information is not required in the uses of RMI-IIOP to access objects
other than enterprise beans.

The RMI-IIOP specification describes how
portable Stub and _Tie_ classes can be created. To be portable to all
implementations that use a CORBA Portable Object Adapter (POA), the
_Tie_ classes must extend the _org.omg.PortableServer.Servant_ class.
This is typically done by using the _-poa_ option to the _rmic_ command.
A Jakarta EE product must provide support for these portable _Stub_ and
_Tie_ classes, typically using the required CORBA POA. However, for
portability to systems that do not use a POA to implement RMI-IIOP,
applications should not depend on the fact that the _Tie_ extends the
_Servant_ class. A Jakarta EE application that defines or uses RMI-IIOP
objects other than enterprise beans must include such portable _Stub_
and _Tie_ classes in the application package. _Stub_ and _Tie_ objects
for enterprise beans, however, must not be included with the
application: they will be generated, if needed, by the Jakarta EE product
at deployment time or at run time.

RMI-IIOP is defined by chapters 5, 6, 13, 15,
and section 10.6.2 of the CORBA 2.3.1 specification, available at
_http://www.omg.org/cgi-bin/doc?formal/99-10-07_ , and by the Jakarta™
Language To IDL Mapping Specification, available at
_http://www.omg.org/cgi-bin/doc?ptc/2000-01-06_ .

=== JNDI

A Jakarta EE product that supports the following
types of objects must be able to make them available in the
application’s JNDI namespace: _EJBHome_ objects, _EJBLocalHome_ objects,
EJB business interface objects, JTA _UserTransaction_ objects, JDBC API
_DataSource_ objects, JMS _ConnectionFactory_ and _Destination_ objects,
JavaMail _Session_ objects, _URL_ objects, resource manager
_ConnectionFactory_ objects (as specified in the Connector
specification), _ORB_ objects, _EntityManagerFactory_ objects, and other
Java language objects as described in
link:#a567[See Resources, Naming, and
Injection].” The JNDI implementation in a Jakarta EE product must be
capable of supporting all of these uses in a single application
component using a single JNDI _InitialContext_ . Application components
will generally create a JNDI _InitialContext_ using the default
constructor with no arguments. The application component may then
perform lookups on that _InitialContext_ to find objects as specified
above.

The names used to perform lookups for Jakarta EE
objects are application dependent. The application component’s metadata
annotations and/or deployment descriptor are used to list the names and
types of objects expected. The Deployer configures the JNDI namespace to
make appropriate components available. The JNDI names used to lookup
such objects must be in the JNDI _java:_ namespace. See
link:#a567[See Resources, Naming, and
Injection]” for details.

Particular names are defined by this
specification for the cases when the Jakarta EE product includes the
corresponding technology. For all application components that have
access to the JTA _UserTransaction_ interface, the appropriate
_UserTransaction_ object can be found using the name
_java:comp/UserTransaction_ . In all containers except the applet
container, application components may lookup a CORBA _ORB_ instance
using the name _java:comp/ORB_ . For all application components that
have access to the CDI _BeanManager_ interface, the appropriate
_BeanManager_ object can be found using the name _java:comp/BeanManager_
. For all application components that have access to the Validation
APIs, the appropriate _Validator_ and _ValidatorFactory_ objects can be
found using the names _java:comp/Validator_ and
_java:comp/ValidatorFactory_ respectively.

The name used to lookup a particular Jakarta EE
object may be different in different application components. In general,
JNDI names can not be meaningfully passed as arguments in remote calls
from one application component to another remote component (for example,
in a call to an _enterprise bean_ ).

The JNDI _java:_ namespace is commonly
implemented as symbolic links to other naming systems. Different
underlying naming services may be used to store different kinds of
objects, or even different instances of objects. It is up to a Jakarta EE
product to provide the necessary JNDI service providers for accessing
the various objects defined in this specification.

This specification requires that the Jakarta EE
platform provide the ability to perform lookup operations as described
above. Different JNDI service providers may provide different
capabilities, for instance, some service providers may provide only
read-only access to the data in the name service.

A Jakarta EE product may be required to provide
a COSNaming name service to meet the EJB interoperability requirements.
In such a case, a COSNaming JNDI service provider must be available
through the web, EJB, and application client containers. It will also
typically be available in the applet container, but this is not
required.

A COSNaming JNDI service provider is a part
of the Java SE 8 SDK and JRE from Oracle, but is not a required
component of the Java SE specification. The COSNaming JNDI service
provider specification is available at
_http://docs.oracle.com/javase/8/docs/technotes/guides/jndi/jndi-cos.html_
.

See
link:#a567[See Resources, Naming, and
Injection]” for the complete naming requirements for the Jakarta EE
platform. The JNDI specification is available at
_http://docs.oracle.com/javase/8/docs/technotes/guides/jndi/index.html_
.

=== Context Class Loader

This specification requires that Jakarta EE
containers provide a per thread context class loader for the use of
system or library classes in dynamically loading classes provided by the
application. The EJB specification requires that all EJB client
containers provide a per thread context class loader for dynamically
loading system value classes. The per thread context class loader is
accessed using the _Thread_ method _getContextClassLoader_ .

The classes used by an application will
typically be loaded by a hierarchy of class loaders. There may be a top
level application class loader, an extension class loader, and so on,
down to a system class loader. The top level application class loader
delegates to the lower class loaders as needed. Classes loaded by lower
class loaders, such as portable EJB system value classes, need to be
able to discover the top level application class loader used to
dynamically load application classes.

This specification requires that containers
provide a per thread context class loader that can be used to load top
level application classes as described above. See
link:#a2966[See Dynamic Class Loading]”
for recommendations for libraries that dynamically load classes.

=== Jakarta™ Authentication and Authorization Service (JAAS) Requirements

All EJB containers and all web containers
must support the use of the JAAS APIs as specified in the Connector
specification. All application client containers must support use of the
JAAS APIs as specified in
link:#a3294[See Application Clients].”

A reference guide to the JAAS APIs is
available at
_http://docs.oracle.com/javase/8/docs/technotes/guides/security/jaas/JAASRefGuide.html_
.

=== Logging API Requirements

The Logging API provides classes and
interfaces in the _java.util.logging_ package that are the Java™
platform’s core logging facilities. This specification does not require
any additional support for logging. A Jakarta EE application typically will
not have the _LoggingPermission_ necessary to control the logging
configuration, but may use the logging API to produce log records. A
future version of this specification may require that the Jakarta EE
containers use the logging API to log certain events.

=== Preferences API Requirements

The Preferences API in the _java.util.prefs_
package allows applications to store and retrieve user and system
preference and configuration data. A Jakarta EE application typically will
not have the _RuntimePermission("preferences")_ necessary to use the
Preferences API. This specification does not define any relationship
between the principal used by a Jakarta EE application and the user
preferences tree defined by the Preferences API. A future version of
this specification may define the use of the Preferences API by Jakarta EE
applications.

=== Enterprise JavaBeans™ (EJB) 3.2 Requirements

This specification requires that a Jakarta EE
product provide support for _enterprise beans_ as specified in the EJB
specification. The EJB specification is available at
_http://jcp.org/en/jsr/summary?id=345_ .

This specification does not impose any
additional requirements at this time. Note that the EJB specification
includes the specification of the EJB interoperability protocol based on
RMI-IIOP. Support for the EJB interoperability protocol is Proposed
Optional in Jakarta EE 8. All containers that support EJB clients must be
capable of using the EJB interoperability protocol to invoke enterprise
beans. All EJB containers must support the invocation of enterprise
beans using the EJB interoperability protocol. A Jakarta EE product may
also support other protocols for the invocation of enterprise beans.

A Jakarta EE product may support multiple object
systems (for example, RMI-IIOP and RMI-JRMP). It may not always be
possible to pass object references from one object system to objects in
another object system. However, when an enterprise bean is using the
RMI-IIOP protocol, it must be possible to pass object references for
RMI-IIOP or Java IDL objects as arguments to methods on such an
enterprise bean, and to return such object references as return values
of a method on such an enterprise bean. In addition, it must be possible
to pass a reference to an RMI-IIOP-based enterprise bean’s Home or
Remote interface to a method on an RMI-IIOP or Java IDL object, or to
return such an enterprise bean object reference as a return value from
such an RMI-IIOP or Java IDL object.

In a Jakarta EE product that includes both an
EJB container and a web container, both containers are required to
support access to local enterprise beans. No support is provided for
access to local enterprise beans from the application client container
or the applet container.

=== Servlet 4.0 Requirements

The Servlet specification defines the
packaging and deployment of web applications, whether standalone or as
part of a Jakarta EE application. The Servlet specification also addresses
security, both standalone and within the Jakarta EE platform. These
optional components of the Servlet specification are requirements of the
Jakarta EE platform.

The Servlet specification includes additional
requirements for web containers that are part of a Jakarta EE product and a
Jakarta EE product must meet these requirements as well.

The Servlet specification defines
distributable web applications. To support Jakarta EE applications that are
distributable, this specification adds the following requirements.

Web containers must support Jakarta EE
distributable web applications placing objects of any of the following
types (when supported by the Jakarta EE product) into a
_javax.servlet.http.HttpSession_ object using the _setAttribute_ or
_putValue_ methods:

=== j _ava.io.Serializable_

*  _javax.ejb.EJBObject_
*  _javax.ejb.EJBHome_
*  _javax.ejb.EJBLocalObject_
*  _javax.ejb.EJBLocalHome_
*  _javax.transaction.UserTransaction_
* a _javax.naming.Context_ object for the
_java:comp/env_ context

=== a reference to an EJB local or remote business interface or no-interface view

Web containers may support objects of other
types as well. Web containers must throw a
_java.lang.IllegalArgumentException_ if an object that is not one of the
above types, or another type supported by the container, is passed to
the _setAttribute_ or _putValue_ methods of an _HttpSession_ object
corresponding to a Jakarta EE distributable session. This exception
indicates to the programmer that the web container does not support
moving the object between VMs. A web container that supports multi-VM
operation must ensure that, when a session is moved from one VM to
another, all objects of supported types are accurately recreated on the
target VM.

The Servlet specification defines access to
local enterprise beans as an optional feature. This specification
requires that all Jakarta EE products that include both a web container and
an EJB container provide support for access to local enterprise beans
from the web container.

The Servlet specification is available at
_http://jcp.org/en/jsr/detail?id=369_ .

=== JavaServer Pages™ (JSP) 2.3 Requirements

The JSP specification depends on and builds
on the servlet framework. A Jakarta EE product must support the entire JSP
specification.

The JSP specification is available at
_http://jcp.org/en/jsr/summary?id=245_ .

=== Expression Language (EL) 3.0 Requirements

The Expression Language specification was
formerly a part of the JavaServer Pages specification. It was split off
into its own specification so that it could be used independently of
JavaServer Pages. A Jakarta EE product must support the Expression
Language.

The Expression Language specification is
available at _http://jcp.org/en/jsr/detail?id=341_ .

=== Jakarta™ Message Service (JMS) 2.0 Requirements

A Java Message Service provider must be
included in a Jakarta EE product that requires support for JMS. The JMS
implementation must provide support for both JMS point-to-point and
publish/subscribe messaging, and thus must make those facilities
available using the _ConnectionFactory_ and _Destination_ APIs.

The JMS specification defines several
interfaces intended for integration with an application server. A Jakarta
EE product need not provide objects that implement these interfaces, and
portable Jakarta EE applications must not use the following interfaces:

* j _avax.jms.ServerSession_
*  _javax.jms.ServerSessionPool_
*  _javax.jms.ConnectionConsumer_

=== all _javax.jms_ XA interfaces

The following methods may only be used by
application components executing in the application client container:

*  _javax.jms.MessageConsumer_ method
_getMessageListener_
*  _javax.jms.MessageConsumer_ method
_setMessageListener_
*  _javax.jms.JMSConsumer_ method
_getMessageListener_
*  _javax.jms.JMSConsumer_ method
_setMessageListener_
*  _javax.jms.Connection_ method
_setExceptionListener_
*  _javax.jms.Connection_ method _stop_
*  _javax.jms.Connection_ method
_setClientID_
*  _javax.jms.JMSContext_ method _stop_
*  _javax.jms.JMSContext_ method
_setClientID_
*  _javax.jms.JMSContext_ method
_setExceptionListener_
*  _javax.jms.JMSContext_ method
_createContext_
*  _javax.jms.Producer_ method _setAsync_
*  _javax.jms.MessageProducer_ method
_send(Message_ _message, CompletionListener_ _completionListener)_
*  _javax.jms.MessageProducer_ method
_send(Message_ _message,_ _int_ _deliveryMode,_ _int_ _priority,_ _long_
_timeToLive,_ _CompletionListener completionListener)_
*  _javax.jms.MessageProducer_ method
_send(Destination_ _destination, Message_ _message,_
_CompletionListener_ _completionListener)_
*  _javax.jms.MessageProducer_ method
_send(Destination_ _destination, Message_ _message,_ _int_
_deliveryMode,_ _int_ _priority,_ _long_ _timeToLive,
CompletionListener_ _completionListener)_

The following methods may only be used by
application components executing in the application client container.
Note, however, that these methods provide an expert facility not used by
ordinary applications. See the JMS specification for further detail.

===  _javax.jms.Session_ method _setMessageListener_

*  _javax.jms.Session_ method
_getMessageListener_
*  _javax.jms.Session_ method _run_
*  _javax.jms.Connection_ method
_createConnectionConsumer_
*  _javax.jms.Connection_ method
_createSharedConnectionConsumer_
*  _javax.jms.Connection_ method
_createDurableConnectionConsumer_

===  _javax.jms.Connection_ method _createSharedDurableConnectionConsumer_

A Jakarta EE container may throw a
_JMSException_ (if allowed by the method) or a _JMSRuntimeException_ (if
throwing a _JMSException_ is not allowed by the method) if the
application component violates any of the above restrictions.

Application components in the web and EJB
containers must not attempt to create more than one active (not closed)
_Session_ object per connection. An attempt to use the _Connection_
object’s _createSession_ method when an active _Session_ object exists
for that connection should be prohibited by the container. The container
should throw a _JMSException_ if the application component violates this
restriction. An attempt to use the _JMSContext_ object’s _createContext_
method should be prohibited by the container. The container should throw
a _JMSRuntimeException_ , since the first _JMSContext_ already contains
a connection and session and this method would create a second session
on the same connection. Application client containers must support the
creation of multiple sessions for each connection.

The JMS specification defines further
restrictions on the use of JMS in the EJB and web containers. In
general, the behavior of a JMS provider should be the same in both the
EJB container and the web container.

The JMS specification is available at
_http://jcp.org/en/jsr/detail?id=343._

=== Jakarta™ Transaction API (JTA) 1.2 Requirements

JTA defines the _UserTransaction_ interface
that is used by applications to start, and commit or abort transactions.
Application components get a _UserTransaction_ object through a JNDI
lookup using the name _java:comp/UserTransaction_ or by requesting
injection of a _UserTransaction_ object.

JTA also defines the
_TransactionSynchronizationRegistry_ interface that can be used by
system level components such as persistence managers to interact with
the transaction manager. These components get a
_TransactionSynchronizationRegistry_ object through a JNDI lookup using
the name _java:comp/TransactionSynchronizationRegistry_ or by requesting
injection of a _TransactionSynchronizationRegistry_ object.

A number of interfaces defined by JTA are used
by an application server to communicate with a transaction manager, and
for a transaction manager to interact with a resource manager. These
interfaces must be supported as described in the Connector
specification. In addition, support for other transaction facilities may
be provided transparently to the application by a Jakarta EE product.

The JTA specification is available at
_http://jcp.org/en/jsr/detail?id=907_ .

=== JavaMail™ 1.6 Requirements

The JavaMail API allows for access to email
messages contained in message stores, and for the creation and sending
of email messages using a message transport. Specific support is
included for Internet standard MIME messages. Access to message stores
and transports is through protocol providers supporting specific store
and transport protocols. The JavaMail API specification does not require
any specific protocol providers, but the JavaMail reference
implementation includes an IMAP message store provider, a POP3 message
store provider, and an SMTP message transport provider.

Configuration of the JavaMail API is
typically done by setting properties in a _Properties_ object that is
used to create a _javax.mail.Session_ object using a static factory
method. To allow the Jakarta EE platform to configure and manage JavaMail
API sessions, an application component that uses the JavaMail API should
request a _Session_ object using JNDI, and should list its need for a
_Session_ object in its deployment descriptor using a _resource-ref_
element, or by using a _Resource_ annotation. A JavaMail API _Session_
object should be considered a resource factory, as described in
link:#a1120[See Resource Manager
Connection Factory References].” This specification requires that the
Jakarta EE platform support _javax.mail.Session_ objects as resource
factories, as described in that section.

The Jakarta EE platform requires that a message
transport be provided that is capable of handling addresses of type
_javax.mail.internet.InternetAddress_ and messages of type
_javax.mail.internet.MimeMessage_ . The default message transport must
be properly configured to send such messages using the _send_ method of
the _javax.mail.Transport_ class. Any authentication needed by the
default transport must be handled without need for the application to
provide a _javax.mail.Authenticator_ or to explicitly connect to the
transport and supply authentication information.

This specification does not require that a Jakarta
EE product support any message store protocols.

Note that the JavaMail API creates threads to
deliver notifications of _Store_ , _Folder_ , and _Transport_ events.
The use of these notification facilities may be limited by the
restrictions on the use of threads in various containers. In EJB
containers, for instance, it is typically not possible to create
threads.

The JavaMail API uses the JavaBeans Activation
Framework API to support various MIME data types. The JavaMail API must
include _javax.activation.DataContentHandlers_ for the following MIME
data types, corresponding to the Java programming language type
indicated in _link:#a2675[See JavaMail
API MIME Data Type to Java Type Mappings]_ .

=== [[a2675]]JavaMail API MIME Data Type to Java Type Mappings

Mime Type

Java Type

 _text/plain_

 _java.lang.String_

 _text/html_

 _java.lang.String_

 _text/xml_

 _java.lang.String_

 _multipart/*_

 _javax.mail.internet.MimeMultipart_

 _message/rfc822_

 _javax.mail.internet.MimeMessage_

The JavaMail API specification is available
at _http://jcp.org/en/jsr/detail?id=919_ .

=== Jakarta™ EE Connector Architecture 1.7 Requirements

In full Jakarta EE products, all EJB containers
and all web containers must support the full set of Connector APIs. All
such containers must support Resource Adapters that use any of the
specified transaction capabilities. The Jakarta EE deployment tools must
support deployment of Resource Adapters, as defined in the Connector
specification, and must support the deployment of applications that use
Resource Adapters.

The Connector specification is available at
_http://jcp.org/en/jsr/detail?id=322_ .

=== Web Services for Jakarta EE 1.4 Requirements

The Web Services for Jakarta EE specification
defines the capabilities a Jakarta EE application server must support for
deployment of web service endpoints. A complete deployment model is
defined, including several new deployment descriptors. All Jakarta EE
products must support the deployment and execution of web services as
specified by the Web Services for Jakarta EE specification (JSR-109).

The Web Services for Jakarta EE specification is
available at _http://jcp.org/en/jsr/detail?id=109_ .

=== Jakarta™ API for XML-based RPC (JAX-RPC) 1.1 Requirements (Optional)

The JAX-RPC specification defines client APIs
for accessing web services as well as techniques for implementing web
service endpoints. The Web Services for Jakarta EE specification describes
the deployment of JAX-RPC-based services and clients. The EJB and
Servlet specifications also describe aspects of such deployment. In Jakarta
EE products that support JAX-RPC, it must be possible to deploy
JAX-RPC-based applications using any of these deployment models.

The JAX-RPC specification describes the
support for message handlers that can process message requests and
responses. In general, these message handlers execute in the same
container and with the same privileges and execution context as the
JAX-RPC client or endpoint component with which they are associated.
These message handlers have access to the same JNDI _java:comp/env_
namespace as their associated component. Custom serializers and
deserializers, if supported, are treated in the same way as message
handlers.

Note that neither web service annotations nor
injection is supported for JAX-RPC service endpoints and handlers. New
applications are encouraged to use JAX-WS to take advantage of these new
facilities that make it easier to write web services.

The JAX-RPC specification is available at
_http://jcp.org/en/jsr/detail?id=101_ .

=== Jakarta™ API for RESTful Web Services (JAX-RS) 2.1 Requirements

JAX-RS defines APIs for the development of
Web services built according to the Representational State Transfer
(REST) architectural style.

In a full Jakarta EE product, all Jakarta EE web
containers are required to support applications that use JAX-RS
technology.

The specification describes the deployment of
services as a servlet. It must be possible to deploy JAX-RS-based
applications using this deployment model with the _servlet-class_
element of the web.xml descriptor naming the application-supplied
extension of the JAX-RS _Application_ abstract class.

The specification defines a set of optional
container-managed facilities and resources that are intended to be
available in a Jakarta EE container — all such features and resources must
be made available.

The JAX-RS specification is available at
_http://jcp.org/en/jsr/summary?id=370_ .

=== Java API for WebSocket 1.1 (WebSocket) Requirements

The Java API for WebSocket (WebSocket) is a
standard API for creating WebSocket applications. In a full Jakarta EE
product, all Jakarta EE web containers are required to support the
WebSocket API.

The Java API for WebSocket specification can
be found at _http://jcp.org/en/jsr/detail?id=356_ .

=== Java API for JSON Processing 1.1 (JSON-P) Requirements

JSON (JavaScript Object Notation) is a
lightweight data-interchange format used by many web services. The Java
API for JSON Processing (JSON-P) provides a convenient way to process
(parse, generate, transform, and query) JSON text.

In a full Jakarta EE product, all Jakarta EE
application client containers, web containers, and EJB containers are
required to support the JSON-P API.

The Java API for JSON Processing
specification can be found at _http://jcp.org/en/jsr/detail?id=374_ .

=== [[a2713]]Java API for JSON Binding 1.0 (JSON-B) Requirements

The Java API for JSON Binding (JSON-B)
provides a convenient way to map between JSON text and Java objects.

In a full Jakarta EE product, all Jakarta EE
application client containers, web containers, and EJB containers are
required to support the JSON-B API.

The Java API for JSON Binding specification
can be found at _http://jcp.org/en/jsr/detail?id=367_ .

=== Concurrency Utilities for Jakarta EE 1.0 (Concurrency Utilities) Requirements

Concurrency Utilities for Jakarta EE is a
standard API for providing asynchronous capabilities to Jakarta EE
application components through the following types of objects: managed
executor service, managed scheduled executor service, managed thread
factory, and context service. In a full Jakarta EE product, all Jakarta EE web
containers and EJB containers are required to support the Concurrency
Utilities API. The Jakarta EE Product Provider must provide preconfigured
default managed executor service, managed scheduled executor service,
managed thread factory, and context service objects for use by the
application in the containers in which the Concurrency Utilities API is
required to be supported.

The Concurrency Utilities for Jakarta EE
specification can be found at _http://jcp.org/en/jsr/detail?id=236_ .

=== Batch Applications for the Java Platform 1.0 (Batch) Requirements

The Batch Applications for the Java Platform
API (Batch) provides a programming model for batch applications and a
runtime for scheduling and executing jobs.

In a full Jakarta EE product, all Jakarta EE web
containers and EJB containers are required to support the Batch API.

The Batch Application for the Java Platform
specification can be found at _http://jcp.org/en/jsr/detail?id=352_ .

=== Jakarta™ API for XML Registries (JAXR) 1.0 Requirements (Optional)

The JAXR specification defines APIs for
client access to XML-based registries such as ebXML registries and UDDI
registries. Jakarta EE products that support JAXR must include a JAXR
registry provider that meets at least the JAXR level 0 requirements.

The JAXR specification is available at
_http://jcp.org/en/jsr/detail?id=93_ .

=== Jakarta™ Platform, Enterprise Edition Management API 1.1 Requirements

The Jakarta EE Management API provides APIs for
management tools to query a Jakarta EE application server to determine its
current status, applications deployed, and so on. All Jakarta EE products
must support this API as described in its specification.

The Jakarta EE Management API specification is
available at _http://jcp.org/en/jsr/detail?id=77_ .

=== [[a2730]]Jakarta™ Platform, Enterprise Edition Deployment API 1.2 Requirements (Optional)

The Jakarta EE Deployment API defines the
interfaces between the runtime environment of a deployment tool and
plug-in components provided by a Jakarta EE application server. These
plug-in components execute in the deployment tool and implement the Jakarta
EE product-specific deployment mechanisms. Jakarta EE products that support
the Jakarta EE Deployment API are required to supply these plug-in
components for use in tools from other vendors.

Note that the Jakarta EE Deployment
specification does not define new APIs for direct use by Jakarta EE
applications. However, it would be possible to create a Jakarta EE
application that acts as a deployment tool and provides the runtime
environment required by the Jakarta EE Deployment specification.

The Jakarta EE Deployment API specification is
available at _http://jcp.org/en/jsr/detail?id=88_ .

=== Jakarta™ Authorization Contract for Containers (JACC) 1.5 Requirements

The JACC specification defines a contract
between a Jakarta EE application server and an authorization policy
provider. In a full Jakarta EE product, all Jakarta EE web containers and
enterprise bean containers are required to support this contract.

The JACC specification can be found at
_http://jcp.org/en/jsr/detail?id=115[]http://jcp.org/en/jsr/detail?id=115._

=== [[a2737]]Jakarta™ Authentication Service Provider Interface for Containers (JASPIC) 1.1 Requirements

The JASPIC specification defines a service
provider interface (SPI) by which authentication providers implementing
message authentication mechanisms may be integrated in client or server
message processing containers or runtimes. Authentication providers
integrated through this interface operate on network messages provided
to them by their calling container. They transform outgoing messages
such that the source of the message may be authenticated by the
receiving container, and the recipient of the message may be
authenticated by the message sender. They authenticate incoming messages
and return to their calling container the identity established as a
result of the message authentication.

In a full Jakarta EE product, all Jakarta EE web
containers and enterprise bean containers are required to support the
baseline compatibility requirements as defined by the JASPIC
specification. In a full Jakarta EE product, all web containers must also
support the Servlet Container Profile as defined in the JASPIC
specification. In a Jakarta EE profile product that includes Servlet and
JASPIC, all web containers must also support the Servlet Container
Profile as defined in the JASPIC specification. Support for the JASPIC
SOAP Profile is not required.

The JASPIC specification can be found at
_http://jcp.org/en/jsr/detail?id=196_ .

=== [[a2741]]Jakarta EE Security API 1.0 Requirements

The Jakarta EE Security API leverages JASPIC,
but provides an easier to use SPI for authentication of users of web
applications and defines identity store APIs for authentication and
authorization.

In a full Jakarta EE product, all Jakarta EE web
containers and enterprise bean containers are required to support the
requirements defined by the Jakarta EE Security API specification.

The Jakarta EE Security API specification can be
found at _http://jcp.org/en/jsr/detail?id=375._

=== Debugging Support for Other Languages (JSR-45) Requirements

JSP pages are usually translated into Java
language pages and then compiled to create class files. The Debugging
Support for Other Languages specification describes information that can
be included in a class file to relate class file data to data in the
original source file. All Jakarta EE products are required to be able to
include such information in class files that are generated from JSP
pages.

The Debugging Support for Other Languages
specification can be found at _http://jcp.org/en/jsr/detail?id=45_ .

=== Standard Tag Library for JavaServer Pages™ (JSTL) 1.2 Requirements

JSTL defines a standard tag library that
makes it easier to develop JSP pages. All Jakarta EE products are required
to provide JSTL for use by all JSP pages.

The Standard Tag Library for JavaServer Pages
specification can be found at _http://jcp.org/en/jsr/detail?id=52_ .

=== Web Services Metadata for the Jakarta™ Platform 2.1 Requirements

The Web Services Metadata for the Java
Platform specification defines Java language annotations that can be
used to simplify the development of web services. These annotations can
be used with JAX-WS web service components.

The Web Services Metadata for the Java
Platform specification can be found at
_http://jcp.org/en/jsr/detail?id=181_ .

=== JavaServer Faces™ 2.3 Requirements

JavaServer Faces technology simplifies
building user interfaces for JavaServer applications. Developers of
various skill levels can quickly build web applications by: assembling
reusable UI components in a page; connecting these components to an
application data source; and wiring client-generated events to
server-side event handlers. In a full Jakarta EE product, all Jakarta EE web
containers are required to support applications that use the JavaServer
Faces technology.

The JavaServer Faces specification can be
found at _http://jcp.org/en/jsr/detail?id=372_ .

=== Common Annotations for the Jakarta™ Platform 1.3 Requirements

The Common Annotations specification defines
Java language annotations that are used by several other specifications,
including this specification. The specifications that use these
annotations fully define the requirements for these annotations. The
applet container need not support any of these annotations. All other
containers must provide definitions for all of these annotations, and
must support the semantics of these annotations as described in the
corresponding specifications and summarized in the following table.

=== Common Annotations Support by Container

Annotation

App Client

Web

EJB

 _Resource_

Y

Y

Y

 _Resources_

Y

Y

Y

 _PostConstruct_

Y

Y

Y

 _PreDestroy_

Y

Y

Y

 _Generated_

N

N

N

 _RunAs_

N

Y

Y

 _DeclareRoles_

N

Y

Y

 _RolesAllowed_

N

Y

Y

 _PermitAll_

N

Y

Y

 _DenyAll_

N

Y

Y

 _ManagedBean_

Y

Y

Y

 _DataSourceDefinition_

Y

Y

Y

 _DataSourceDefinitions_

Y

Y

Y

Priority

Y

Y

Y

The Common Annotations for the Java Platform
specification can be found at _http://jcp.org/en/jsr/detail?id=250_ .

=== Jakarta™ Persistence API 2.2 Requirements

Java Persistence is the standard API for the
management of persistence and object/relational mapping. The Java
Persistence specification provides an object/relational mapping facility
for application developers using a Java domain model to manage a
relational database.

As mandated by the Java Persistence
specification, in a Jakarta EE environment the classes of the persistence
unit should not be loaded by the application class loader or any of its
parent class loaders until after the entity manager factory for the
persistence unit has been created.

The Java Persistence specification can be
found at _http://jcp.org/en/jsr/detail?id=338_ .

=== Bean Validation 2.0 Requirements

The Bean Validation specification defines a
metadata model and API for JavaBean validation. The default metadata
source is annotations, with the ability to override and extend the
metadata through the use of XML validation descriptors.

The Jakarta EE platform requires that web
containers make an instance of _ValidatorFactory_ available to JSF
implementations by storing it in a servlet context attribute named
_javax.faces.validator.beanValidator.ValidatorFactory._

The Jakarta EE platform also requires that an
instance of _ValidatorFactory_ be made available to JPA providers as a
property in the map that is passed as the second argument to the
_createContainerEntityManagerFactory(PersistenceUnitInfo, Map)_ method
of the _PersistenceProvider_ interface, under the name
_javax.persistence.validation.factory_ .

Additional requirements on Jakarta EE platform
containers are specified in the Bean Validation specification, which can
be found at _http://jcp.org/en/jsr/detail?id=380_ .

=== Managed Beans 1.0 Requirements

The Managed Beans specification defines a
lightweight component model that supports the basic lifecycle model,
resource injection facility and interceptor service present in the Jakarta
EE platform.

The Managed Beans specification can be found
at _http://jcp.org/en/jsr/detail?id=316_ .

=== Interceptors 1.2 Requirements

The Interceptors specification makes more
generally available the interceptor facility originally defined as part
of the EJB 3.0 specification.

The Interceptors specification can be found
at _http://jcp.org/en/jsr/detail?id=318_ .

=== Contexts and Dependency Injection for the Jakarta EE Platform 2.0 Requirements

The Contexts and Dependency Injection (CDI)
specification defines a set of contextual services, provided by Jakarta EE
containers, aimed at simplifying the creation of applications that use
both web tier and business tier technologies.

The CDI specification can be found at
_http://jcp.org/en/jsr/detail?id=365_ .

=== Dependency Injection for Java 1.0 Requirements

The Dependency Injection for Java (DI)
specification defines a standard set of annotations (and one interface)
for use on injectable classes.

In the Jakarta EE platform, support for
Dependency Injection is mediated by CDI. See
link:#a2112[See Support for Dependency
Injection]” for more detail.

The DI specification can be found at
_http://jcp.org/en/jsr/detail?id=330_ .
